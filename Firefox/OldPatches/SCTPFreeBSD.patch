changeset:   272824:16c960e06ed4
tag:         tip
user:        ruengeler <i.ruengeler@fh-muenster.de>
date:        Wed Dec 02 09:43:33 2015 +0100
summary:     SCTP support for FreeBsd, Linux and Darwin

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -2616,16 +2616,40 @@ MOZ_CHECK_COMMON_HEADERS
 
 dnl These are all the places some variant of statfs can be hiding.
 MOZ_CHECK_HEADERS(sys/statvfs.h sys/statfs.h sys/vfs.h sys/mount.h)
 
 dnl Quota support
 MOZ_CHECK_HEADERS(sys/quota.h sys/sysmacros.h)
 MOZ_CHECK_HEADERS([linux/quota.h],,,[#include <sys/socket.h>])
 
+dnl enable SCTP
+MOZ_ARG_ENABLE_BOOL(sctp,
+[  --enable-sctp          Build with SCTP support enabled],
+    ENABLE_SCTP=1,
+    ENABLE_SCTP=)
+AC_MSG_CHECKING([whether SCTP is supported])
+if test -n "$ENABLE_SCTP"; then
+    AC_DEFINE(ENABLE_SCTP)
+fi
+
+AC_SUBST(ENABLE_SCTP)
+
+    case "${target_os}" in
+    	freebsd*)
+            AC_DEFINE(SCTP_HAVE_EXTRCVINFO)
+            AC_DEFINE(SCTP_1_BYTE_PEEK)
+            ;;    
+    	darwin*)
+            AC_DEFINE(SCTP_HAVE_EXTRCVINFO)
+            AC_DEFINE(SCTP_1_BYTE_PEEK)
+            LDFLAGS="$LDFLAGS -lsctp"
+            ;;
+    esac
+    
 dnl SCTP support - needs various network include headers
 MOZ_CHECK_HEADERS([linux/if_addr.h linux/rtnetlink.h],,,[#include <sys/socket.h>])
 MOZ_CHECK_HEADERS(sys/queue.h)
 
 MOZ_CHECK_HEADERS(sys/types.h netinet/in.h byteswap.h)
 
 dnl Check for sin_len and sin6_len - used by SCTP; only appears in Mac/*BSD generally
 AC_CACHE_CHECK(for sockaddr_in.sin_len,
diff --git a/media/mtransport/transportlayerdtls.cpp b/media/mtransport/transportlayerdtls.cpp
--- a/media/mtransport/transportlayerdtls.cpp
+++ b/media/mtransport/transportlayerdtls.cpp
@@ -273,16 +273,35 @@ static PRStatus TransportLayerGetpeernam
   // elsewhere
   addr->inet.family = PR_AF_INET;
   addr->inet.port = 0;
   addr->inet.ip = 0;
 
   return PR_SUCCESS;
 }
 
+#if defined(ENABLE_SCTP)
+static int32_t TransportLayerSctp_recvmsg(PRFileDesc *fd, void *buf,
+    PRInt32 amount, PRNetAddr *from, PRUint32 *fromlen,
+    PRSctp_SndRcvInfo *sinfo, PRInt32 *msgflags,
+    PRIntervalTime timeout) {
+    UNIMPLEMENTED;
+    return -1;
+}
+
+static int32_t TransportLayerSctp_sendmsg(PRFileDesc *fd, const void *buf,
+    PRInt32 amount, const PRNetAddr *to, PRUint32 tolen, PRInt32 ppid,
+    PRUint32 flags, PRInt16 stream, PRInt32 timetolive, PRInt32 context,
+    PRIntervalTime timeout)
+{
+    UNIMPLEMENTED;
+    return -1;
+}
+#endif
+
 static PRStatus TransportLayerGetsockname(PRFileDesc *f, PRNetAddr *addr) {
   UNIMPLEMENTED;
   return PR_FAILURE;
 }
 
 static PRStatus TransportLayerGetsockoption(PRFileDesc *f, PRSocketOptionData *opt) {
   switch (opt->option) {
     case PR_SockOpt_Nonblocking:
@@ -350,18 +369,23 @@ static const struct PRIOMethods Transpor
   TransportLayerSend,
   TransportLayerRecvfrom,
   TransportLayerSendto,
   TransportLayerPoll,
   TransportLayerAcceptRead,
   TransportLayerTransmitFile,
   TransportLayerGetsockname,
   TransportLayerGetpeername,
+#if defined(ENABLE_SCTP)
+  TransportLayerSctp_recvmsg,
+  TransportLayerSctp_sendmsg,
+#else
   TransportLayerReserved,
   TransportLayerReserved,
+#endif
   TransportLayerGetsockoption,
   TransportLayerSetsockoption,
   TransportLayerSendfile,
   TransportLayerConnectContinue,
   TransportLayerReserved,
   TransportLayerReserved,
   TransportLayerReserved,
   TransportLayerReserved
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -4063,16 +4063,24 @@ pref("font.name.monospace.x-cyrillic", "
 // Override default Unicode fonts
 pref("font.name.serif.x-unicode", "dt-interface system-ucs2.cjk_japan-0");
 pref("font.name.sans-serif.x-unicode", "dt-interface system-ucs2.cjk_japan-0");
 pref("font.name.monospace.x-unicode", "dt-interface user-ucs2.cjk_japan-0");
 
 # AIX
 #endif
 
+#ifdef ENABLE_SCTP
+pref("browser.startup.homepage_override.mstone", "ignore");
+pref("network.http.pipelining"      , true);
+pref("network.http.proxy.pipelining", true);
+pref("network.http.pipelining.maxrequests" , 15);
+pref("network.http.sctp.max-number-of-outgoing-streams" , 50);
+#endif
+
 // Login Manager prefs
 pref("signon.rememberSignons",              true);
 pref("signon.rememberSignons.visibilityToggle", true);
 pref("signon.autofillForms",                true);
 pref("signon.autologin.proxy",              false);
 pref("signon.storeWhenAutocompleteOff",     true);
 pref("signon.ui.experimental",              false);
 pref("signon.debug",                        false);
diff --git a/netwerk/base/nsISocketTransport.idl b/netwerk/base/nsISocketTransport.idl
--- a/netwerk/base/nsISocketTransport.idl
+++ b/netwerk/base/nsISocketTransport.idl
@@ -111,16 +111,30 @@ interface nsISocketTransport : nsITransp
     void          setTimeout(in unsigned long aType, in unsigned long aValue);
 
     /**
      * Values for the aType parameter passed to get/setTimeout.
      */
     const unsigned long TIMEOUT_CONNECT    = 0;
     const unsigned long TIMEOUT_READ_WRITE = 1;
 
+    // Get the SCTP stream on which the next piece of data will be read.
+    readonly attribute int32_t nextSctpInputStreamId;
+
+    // Get the SCTP stream on which the next piece of data will be written.
+
+    readonly attribute int32_t nextSctpOutputStreamId;
+
+    // Get the number of SCTP output streams allowed for this association.
+
+    readonly attribute int32_t numberOfSctpStreams;
+
+    // Is the socket an SCTP 1-to-1 style socket?
+    boolean isSctpSocket();
+
     /**
      * nsITransportEventSink status codes.
      *
      * Although these look like XPCOM error codes and are passed in an nsresult
      * variable, they are *not* error codes.  Note that while they *do* overlap
      * with existing error codes in Necko, these status codes are confined
      * within a very limited context where no error codes may appear, so there
      * is no ambiguity.
diff --git a/netwerk/base/nsSocketTransport2.cpp b/netwerk/base/nsSocketTransport2.cpp
--- a/netwerk/base/nsSocketTransport2.cpp
+++ b/netwerk/base/nsSocketTransport2.cpp
@@ -29,16 +29,21 @@
 #include "nsISocketProvider.h"
 #include "nsISSLSocketControl.h"
 #include "nsIPipe.h"
 #include "nsIClassInfoImpl.h"
 #include "nsURLHelper.h"
 #include "nsIDNSService.h"
 #include "nsIDNSRecord.h"
 #include "nsICancelable.h"
+#if defined(ENABLE_SCTP)
+#include "prsctp.h"
+#include "nsIPrefBranch.h"
+#endif
+
 #include <algorithm>
 
 #include "nsPrintfCString.h"
 
 #if defined(XP_WIN)
 #include "nsNativeConnectionHelper.h"
 #endif
 
@@ -382,25 +387,56 @@ nsSocketInputStream::Read(char *buf, uin
         if (NS_FAILED(mCondition))
             return (mCondition == NS_BASE_STREAM_CLOSED) ? NS_OK : mCondition;
 
         fd = mTransport->GetFD_Locked();
         if (!fd)
             return NS_BASE_STREAM_WOULD_BLOCK;
     }
 
-    SOCKET_LOG(("  calling PR_Read [count=%u]\n", count));
-
     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
     // synchronously proxies notifications over to the UI thread, which could
     // mistakenly try to re-enter this code.)
-    int32_t n = PR_Read(fd, buf, count);
-
-    SOCKET_LOG(("  PR_Read returned [n=%d]\n", n));
-
+
+    int32_t n;
+
+#if defined(ENABLE_SCTP)
+    if (PR_GetDescType(PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+        PRNetAddr from;
+        uint32_t fromlen;
+#if defined(SCTP_HAVE_EXTRCVINFO)
+        PRSctp_ExtRcvInfo eri;            // Darwin & FreeBSD only
+#else
+        PRSctp_SndRcvInfo eri;
+#endif
+        PRSctp_SndRcvInfo *sri = (PRSctp_SndRcvInfo *)&eri;
+        int32_t msg_flags;
+        fromlen = sizeof(from);
+        memset(&eri, 0, sizeof(eri));
+        msg_flags = 0;
+        SOCKET_LOG(("  calling PR_SctpRecvmsg [count=%u]\n", count));
+        n = PR_SctpRecvmsg(fd, buf, count, &from, &fromlen, sri, &msg_flags,
+                           PR_INTERVAL_NO_TIMEOUT);
+        SOCKET_LOG(("  PR_SctpRecvmsg returned [n=%d]\n", n));
+        mTransport->mNextSctpInputStreamId = -1;
+#if defined(SCTP_HAVE_EXTRCVINFO)
+        if (n > 0 && eri.serinfo_next_flags & SCTP_NEXT_MSG_AVAIL)
+            mTransport->mNextSctpInputStreamId = eri.serinfo_next_stream;
+#endif
+    }
+    else
+    {
+#endif
+        SOCKET_LOG(("  calling PR_Read [count=%u]\n", count));
+        n = PR_Read(fd, buf, count);
+        SOCKET_LOG(("  PR_Read returned [n=%d]\n", n));
+#if defined(ENABLE_SCTP)
+    }
+#endif
     nsresult rv = NS_OK;
     {
         MutexAutoLock lock(mTransport->mLock);
 
 #ifdef ENABLE_SOCKET_TRACING
         if (n > 0)
             mTransport->TraceInBuf(buf, n);
 #endif
@@ -492,17 +528,16 @@ nsSocketInputStream::AsyncWait(nsIInputS
         // OnSocketEvent will call OnInputStreamReady with an error code after
         // going through the event loop. We do this because most socket callers
         // do not expect AsyncWait() to synchronously execute the OnInputStreamReady
         // callback.
         mTransport->PostEvent(nsSocketTransport::MSG_INPUT_PENDING);
     } else {
         mTransport->OnInputPending();
     }
-
     return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // socket output stream impl 
 //-----------------------------------------------------------------------------
 
 nsSocketOutputStream::nsSocketOutputStream(nsSocketTransport *trans)
@@ -599,25 +634,49 @@ nsSocketOutputStream::Write(const char *
         if (NS_FAILED(mCondition))
             return mCondition;
         
         fd = mTransport->GetFD_Locked();
         if (!fd)
             return NS_BASE_STREAM_WOULD_BLOCK;
     }
 
-    SOCKET_LOG(("  calling PR_Write [count=%u]\n", count));
-
     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
     // synchronously proxies notifications over to the UI thread, which could
     // mistakenly try to re-enter this code.)
-    int32_t n = PR_Write(fd, buf, count);
-
-    SOCKET_LOG(("  PR_Write returned [n=%d]\n", n));
-
+  //  int32_t n = PR_Write(fd, buf, count);
+
+    int32_t n;
+#if defined(ENABLE_SCTP)
+    uint16_t SendStream;
+
+    if (PR_GetDescType(PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+        SendStream = mTransport->mNextSctpOutputStreamId;
+        NS_ASSERTION(SendStream >= 0 &&
+                     SendStream < mTransport->mNumberOfSctpStreams,
+                     "Invalid SCTP stream ID");
+        SOCKET_LOG(("  calling PR_SctpSendmsg [count=%u]\n", count));
+        n = PR_SctpSendmsg(fd, buf, count, NULL, 0, 0, 0, SendStream, 0, 0, 0);
+        SOCKET_LOG(("  PR_Sctp_Sendmsg returned [n=%d]\n", n));
+
+        if (n > 0)
+            mTransport->mNextSctpOutputStreamId =
+                ++(mTransport->mNextSctpOutputStreamId) %
+                mTransport->mNumberOfSctpStreams;
+    }
+    else
+#endif
+    {
+        SOCKET_LOG(("  calling PR_Write [count=%u]\n", count));
+
+        n = PR_Write(fd, buf, count);
+
+        SOCKET_LOG(("  PR_Write returned [n=%d]\n", n));
+    }
     nsresult rv = NS_OK;
     {
         MutexAutoLock lock(mTransport->mLock);
 
 #ifdef ENABLE_SOCKET_TRACING
         if (n > 0)
             mTransport->TraceOutBuf(buf, n);
 #endif
@@ -750,16 +809,21 @@ nsSocketTransport::nsSocketTransport()
     , mFDconnected(false)
     , mSocketTransportService(gSocketTransportService)
     , mInput(this)
     , mOutput(this)
     , mQoSBits(0x00)
     , mKeepaliveEnabled(false)
     , mKeepaliveIdleTimeS(-1)
     , mKeepaliveRetryIntervalS(-1)
+#ifdef ENABLE_SCTP
+    , mNextSctpInputStreamId (-1)
+    , mNextSctpOutputStreamId (-1)
+    , mNumberOfSctpStreams (-1)
+#endif
     , mKeepaliveProbeCount(-1)
 {
     SOCKET_LOG(("creating nsSocketTransport @%p\n", this));
 
     mTimeouts[TIMEOUT_CONNECT]    = UINT16_MAX; // no timeout
     mTimeouts[TIMEOUT_READ_WRITE] = UINT16_MAX; // no timeout
 }
 
@@ -1080,18 +1144,75 @@ nsSocketTransport::BuildSocket(PRFileDes
     SOCKET_LOG(("nsSocketTransport::BuildSocket [this=%p]\n", this));
 
     nsresult rv;
 
     proxyTransparent = false;
     usingSSL = false;
 
     if (mTypeCount == 0) {
+#if defined(ENABLE_SCTP)
+        fd = PR_OpenSCTPOneToOneSocket(mNetAddr.raw.family);
+#else
         fd = PR_OpenTCPSocket(mNetAddr.raw.family);
+#endif
         rv = fd ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+#if defined(ENABLE_SCTP)
+        if (PR_GetDescType(PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+            if (NS_SUCCEEDED(rv)) {
+                // Subscribe to sctp_data_io_event.
+                PRSocketOptionData sod;
+                memset(&sod, 0, sizeof(sod));
+                sod.option = PR_SockOpt_Events;
+                sod.value.events.sctp_data_io_event = 1;
+                if (PR_SetSocketOption(fd, &sod) != PR_SUCCESS) {
+                    return NS_ERROR_SOCKET_OPTION_FAILED;
+                }
+                // Enable sctp_extrcvinfo.  Darwin & FreeBSD only
+#if defined(SCTP_HAVE_EXTRCVINFO)
+                memset(&sod, 0, sizeof(sod));
+                sod.option = PR_SockOpt_UseExtRcvInfo;
+                sod.value.useextrcvinfo = true;
+                if (PR_SetSocketOption(fd, &sod) != PR_SUCCESS)
+                    return NS_ERROR_SOCKET_OPTION_FAILED;
+#endif
+                // Get the current values for SCTP_INITMSG.
+                memset(&sod, 0, sizeof(sod));
+                sod.option = PR_SockOpt_InitMsg;
+                if (PR_SetSocketOption(fd, &sod) != PR_SUCCESS) {
+                    return NS_ERROR_SOCKET_OPTION_FAILED;
+                }
+                // Retrieve the max outgoing stream preference setting
+                nsCOMPtr<nsIPrefBranch> prefs =
+                    do_GetService("@mozilla.org/preferences-service;1", &rv);
+                if (NS_FAILED(rv)) {
+                    return rv;
+                }
+
+                rv = NS_OK;
+                int32_t val = 0;
+                if (mNumberOfSctpStreams == 0) {
+                    rv = mSocketTransportService->GetMaxNumberOfSctpStreams(&val);
+                    if (NS_WARN_IF(NS_FAILED(rv))) {
+                        return rv;
+                    }
+                }
+
+                // Set the maximum number of outgoing SCTP streams.
+                sod.value.initmsg.sinit_num_ostreams = (uint16_t) val;
+                sod.option = PR_SockOpt_InitMsg;
+                if (PR_SetSocketOption(fd, &sod) != PR_SUCCESS) {
+                    return NS_ERROR_SOCKET_OPTION_FAILED;
+                }
+                // Initialize next SCTP output stream ID.
+                mNextSctpOutputStreamId = 0;
+            }
+        }
+#endif
     }
     else {
 #if defined(XP_UNIX)
         MOZ_ASSERT(!mNetAddrIsSet || mNetAddr.raw.family != AF_LOCAL,
                    "Unix domain sockets can't be used with socket types");
 #endif
 
         fd = nullptr;
@@ -1201,17 +1322,17 @@ nsSocketTransport::BuildSocket(PRFileDes
     }
 
     return rv;
 }
 
 nsresult
 nsSocketTransport::InitiateSocket()
 {
-    SOCKET_LOG(("nsSocketTransport::InitiateSocket [this=%p]\n", this));
+    SOCKET_LOG(("!!!!!!!!!!!!nsSocketTransport::InitiateSocket [this=%p]\n", this));
 
     static int crashOnNonLocalConnections = -1;
     if (crashOnNonLocalConnections == -1) {
         const char *s = getenv("MOZ_DISABLE_NONLOCAL_CONNECTIONS");
         if (s) {
             crashOnNonLocalConnections = !!strncmp(s, "0", 1);
         } else {
             crashOnNonLocalConnections = 0;
@@ -1390,68 +1511,78 @@ nsSocketTransport::InitiateSocket()
     //
     // Initiate the connect() to the host...
     //
     PRNetAddr prAddr;
     {
         if (mBindAddr) {
             MutexAutoLock lock(mLock);
             NetAddrToPRNetAddr(mBindAddr.get(), &prAddr);
+
             status = PR_Bind(fd, &prAddr);
+
             if (status != PR_SUCCESS) {
                 return NS_ERROR_FAILURE;
             }
             mBindAddr = nullptr;
         }
     }
 
     NetAddrToPRNetAddr(&mNetAddr, &prAddr);
 
     // We use PRIntervalTime here because we need
     // nsIOService::LastOfflineStateChange time and
     // nsIOService::LastConectivityChange time to be atomic.
     PRIntervalTime connectStarted = 0;
     if (gSocketTransportService->IsTelemetryEnabled()) {
         connectStarted = PR_IntervalNow();
     }
-
     status = PR_Connect(fd, &prAddr, NS_SOCKET_CONNECT_TIMEOUT);
-
     if (gSocketTransportService->IsTelemetryEnabled() && connectStarted) {
         SendPRBlockingTelemetry(connectStarted,
             Telemetry::PRCONNECT_BLOCKING_TIME_NORMAL,
             Telemetry::PRCONNECT_BLOCKING_TIME_SHUTDOWN,
             Telemetry::PRCONNECT_BLOCKING_TIME_CONNECTIVITY_CHANGE,
             Telemetry::PRCONNECT_BLOCKING_TIME_LINK_CHANGE,
             Telemetry::PRCONNECT_BLOCKING_TIME_OFFLINE);
     }
 
     if (status == PR_SUCCESS) {
+        SOCKET_LOG(("We are connected\n"));
         // 
         // we are connected!
         //
+#if defined(ENABLE_SCTP)
+        rv = SetNumberOfOutgoingSctpStreams(fd);
+        if(NS_FAILED(rv))
+            return rv;
+#endif
         OnSocketConnected();
-    }
-    else {
+    } else {
         PRErrorCode code = PR_GetError();
 #if defined(TEST_CONNECT_ERRORS)
         code = RandomizeConnectError(code);
 #endif
         //
         // If the PR_Connect(...) would block, then poll for a connection.
         //
-        if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code))
+        if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code)) {
             mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
         //
         // If the socket is already connected, then return success...
         //
-        else if (PR_IS_CONNECTED_ERROR == code) {
+        } else if (PR_IS_CONNECTED_ERROR == code) {
             //
             // we are connected!
             //
+#if defined(ENABLE_SCTP)
+            rv = SetNumberOfOutgoingSctpStreams(fd);
+            if(NS_FAILED(rv))
+               return rv;
+#endif
             OnSocketConnected();
 
             if (mSecInfo && !mProxyHost.IsEmpty() && proxyTransparent && usingSSL) {
                 // if the connection phase is finished, and the ssl layer has
                 // been pushed, and we were proxying (transparently; ie. nothing
                 // has to happen in the protocol layer above us), it's time for
                 // the ssl to start doing it's thing.
                 nsCOMPtr<nsISSLSocketControl> secCtrl =
@@ -1664,27 +1795,55 @@ nsSocketTransport::OnSocketConnected()
     // to trample over mFDref if mFD is already set.
     {
         MutexAutoLock lock(mLock);
         NS_ASSERTION(mFD.IsInitialized(), "no socket");
         NS_ASSERTION(mFDref == 1, "wrong socket ref count");
         mFDconnected = true;
     }
 
+#ifndef ENABLE_SCTP
     // Ensure keepalive is configured correctly if previously enabled.
     if (mKeepaliveEnabled) {
         nsresult rv = SetKeepaliveEnabledInternal(true);
         if (NS_WARN_IF(NS_FAILED(rv))) {
             SOCKET_LOG(("  SetKeepaliveEnabledInternal failed rv[0x%x]", rv));
         }
     }
+#endif
 
     SendStatus(NS_NET_STATUS_CONNECTED_TO);
 }
 
+#if defined(ENABLE_SCTP)
+NS_IMETHODIMP
+nsSocketTransport::SetNumberOfOutgoingSctpStreams(PRFileDesc *fd)
+{
+    nsresult rv;
+    bool socketIsSctp;
+
+    rv = IsSctpSocket(&socketIsSctp);
+    if (NS_FAILED(rv))
+        return rv;
+    if (!socketIsSctp)
+        return NS_ERROR_INVALID_SOCKET_TYPE;
+
+    // Get status to see how many outgoing streams were allowed by remote host
+    PRSocketOptionData sod;
+    memset(&sod, 0, sizeof(sod));
+    sod.option = PR_SockOpt_Status;
+    if (PR_GetSocketOption(fd, &sod) != PR_SUCCESS)
+        return NS_ERROR_SOCKET_OPTION_FAILED;
+
+    // Set number of outgoing SCTP streams
+    mNumberOfSctpStreams = sod.value.status.sstat_outstrms;
+    return NS_OK;
+}
+#endif
+
 PRFileDesc *
 nsSocketTransport::GetFD_Locked()
 {
     mLock.AssertCurrentThreadOwns();
 
     // mFD is not available to the streams while disconnected.
     if (!mFDconnected)
         return nullptr;
@@ -1738,16 +1897,156 @@ nsSocketTransport::ReleaseFD_Locked(PRFi
         } else {
             // Can't PR_Close() a socket off STS thread. Thunk it to STS to die
             STS_PRCloseOnSocketTransport(mFD);
         }
         mFD = nullptr;
     }
 }
 
+#if defined(ENABLE_SCTP)
+// Update mNextSctpInputStreamId by doing a peek
+NS_IMETHODIMP
+nsSocketTransport::UpdateNextSctpInputStreamId()
+{
+    nsresult rv = NS_OK;
+    char c;
+    int32_t n;
+    PRNetAddr from;
+    uint32_t fromlen;
+    int msg_flags = PR_MSG_PEEK;
+#if defined(SCTP_HAVE_EXTRCVINFO)
+    PRSctp_ExtRcvInfo eri;            // Darwin & FreeBSD only
+#else
+    PRSctp_SndRcvInfo eri;
+#endif
+    PRSctp_SndRcvInfo *sri = (PRSctp_SndRcvInfo*)&eri;
+    fromlen = sizeof(from);
+    memset(sri, 0, sizeof(eri));
+    {
+    MutexAutoLock lock(mLock);
+#if defined(SCTP_1_BYTE_PEEK)  // Some implementations must read a byte to peek
+    n = PR_SctpRecvmsg(mFD, &c, 1, &from, &fromlen, sri, &msg_flags, 0);
+#else                          // Some linux implementations consume bytes when peeking
+    n = PR_SctpRecvmsg(mFD, &c, 1, &from, &fromlen, sri, &msg_flags, 0);
+#endif
+    }
+    mNextSctpInputStreamId = -1;
+
+    if (n >= 0) {
+        if (n == 0 && PR_GetError() == PR_NOT_CONNECTED_ERROR) {
+            rv = NS_BASE_STREAM_CLOSED;
+        } else {
+            mNextSctpInputStreamId = sri->sinfo_stream;
+            NS_ASSERTION(mNextSctpInputStreamId >= 0 &&
+                         mNextSctpInputStreamId < mNumberOfSctpStreams,
+                         "Invalid SCTP stream ID");
+        }
+    } else if (PR_GetError() == PR_WOULD_BLOCK_ERROR) {
+        rv = NS_BASE_STREAM_WOULD_BLOCK;
+    } else {
+        rv = NS_BASE_STREAM_CLOSED;
+    }
+    return rv;
+}
+#endif
+
+
+NS_IMETHODIMP
+nsSocketTransport::GetNextSctpInputStreamId(int32_t* aSctpStreamID)
+{
+#if !defined(ENABLE_SCTP)
+    return NS_ERROR_NOT_IMPLEMENTED;
+#else
+    nsresult rv;
+    bool socketIsSctp;
+
+    rv = IsSctpSocket(&socketIsSctp);
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+    if (!socketIsSctp)
+        return NS_ERROR_INVALID_SOCKET_TYPE;
+    else
+        rv = NS_OK;
+
+    // If mNextSctpInputStreamId is invalid, update it.
+    if (mNextSctpInputStreamId == -1) {
+        rv = UpdateNextSctpInputStreamId();
+    }
+    *aSctpStreamID = mNextSctpInputStreamId;
+    return rv;
+#endif
+}
+
+NS_IMETHODIMP
+nsSocketTransport::GetNextSctpOutputStreamId(int32_t* aSctpStreamID)
+{
+#if !defined(ENABLE_SCTP)
+    return NS_ERROR_NOT_IMPLEMENTED;
+#else
+    nsresult rv = NS_ERROR_FAILURE;
+    bool socketIsSctp;
+
+    rv = IsSctpSocket(&socketIsSctp);
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+    if (!socketIsSctp) {
+        return NS_ERROR_INVALID_SOCKET_TYPE;
+    }
+
+    *aSctpStreamID = mNextSctpOutputStreamId;
+    return NS_OK;
+#endif
+}
+
+NS_IMETHODIMP
+nsSocketTransport::GetNumberOfSctpStreams(int32_t* aNumberOfStreams)
+{
+#if !defined(ENABLE_SCTP)
+    return NS_ERROR_NOT_IMPLEMENTED;
+#else
+    nsresult rv;
+    bool socketIsSctp;
+
+    rv = IsSctpSocket(&socketIsSctp);
+    if (NS_FAILED(rv))
+        return rv;
+    if (!socketIsSctp)
+        return NS_ERROR_INVALID_SOCKET_TYPE;
+
+    *aNumberOfStreams = mNumberOfSctpStreams;
+    return NS_OK;
+#endif
+}
+
+NS_IMETHODIMP
+nsSocketTransport::IsSctpSocket(bool *aResult)
+{
+#if !defined(ENABLE_SCTP)
+    return NS_ERROR_NOT_IMPLEMENTED;
+#else
+    {
+    MutexAutoLock lock(mLock);
+    *aResult = false;
+    if (mFD.IsInitialized()) {
+        if (PR_GetDescType(PR_GetIdentitiesLayer(mFD, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+            *aResult = true;
+        }
+        return NS_OK;
+    }
+    else {
+        return NS_ERROR_SOCKET_DOES_NOT_EXIST;
+    }
+    }
+#endif
+}
+
 //-----------------------------------------------------------------------------
 // socket event handler impl
 
 void
 nsSocketTransport::OnSocketEvent(uint32_t type, nsresult status, nsISupports *param)
 {
     SOCKET_LOG(("nsSocketTransport::OnSocketEvent [this=%p type=%u status=%x param=%p]\n",
         this, type, status, param));
@@ -1770,19 +2069,19 @@ nsSocketTransport::OnSocketEvent(uint32_
         // ensure that we have created a socket, attached it, and have a
         // connection.
         //
         if (mState == STATE_CLOSED) {
             // Unix domain sockets are ready to connect; mNetAddr is all we
             // need. Internet address families require a DNS lookup (or possibly
             // several) before we can connect.
 #if defined(XP_UNIX)
-            if (mNetAddrIsSet && mNetAddr.raw.family == AF_LOCAL)
+            if (mNetAddrIsSet && mNetAddr.raw.family == AF_LOCAL) {
                 mCondition = InitiateSocket();
-            else
+            } else
 #endif
                 mCondition = ResolveHost();
 
         } else {
             SOCKET_LOG(("  ignoring redundant event\n"));
         }
         break;
 
@@ -1804,18 +2103,19 @@ nsSocketTransport::OnSocketEvent(uint32_
             // transport resolves the real host here, so there's no fixup 
             // (see bug 226943).
             if ((status == NS_ERROR_UNKNOWN_HOST) && !mProxyTransparent &&
                 !mProxyHost.IsEmpty())
                 mCondition = NS_ERROR_UNKNOWN_PROXY_HOST;
             else
                 mCondition = status;
         }
-        else if (mState == STATE_RESOLVING)
+        else if (mState == STATE_RESOLVING) {
             mCondition = InitiateSocket();
+        }
         break;
 
     case MSG_RETRY_INIT_SOCKET:
         mCondition = InitiateSocket();
         break;
 
     case MSG_INPUT_CLOSED:
         SOCKET_LOG(("  MSG_INPUT_CLOSED\n"));
@@ -1845,18 +2145,19 @@ nsSocketTransport::OnSocketEvent(uint32_
         SOCKET_LOG(("  unhandled event!\n"));
     }
     
     if (NS_FAILED(mCondition)) {
         SOCKET_LOG(("  after event [this=%p cond=%x]\n", this, mCondition));
         if (!mAttached) // need to process this error ourselves...
             OnSocketDetached(nullptr);
     }
-    else if (mPollFlags == PR_POLL_EXCEPT)
+    else if (mPollFlags == PR_POLL_EXCEPT) {
         mPollFlags = 0; // make idle
+    }
 }
 
 //-----------------------------------------------------------------------------
 // socket handler impl
 
 void
 nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16_t outFlags)
 {
@@ -1877,16 +2178,28 @@ nsSocketTransport::OnSocketReady(PRFileD
             mPollFlags &= ~PR_POLL_WRITE;
             mOutput.OnSocketReady(NS_OK);
         }
         // if waiting to read and socket is readable or hit an exception.
         if ((mPollFlags & PR_POLL_READ) && (outFlags & ~PR_POLL_WRITE)) {
             // assume that we won't need to poll any longer (the stream will
             // request that we poll again if it is still pending).
             mPollFlags &= ~PR_POLL_READ;
+
+#if defined(ENABLE_SCTP)
+            // if SCTP socket, get stream on which data arrived
+            if (PR_GetDescType(PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+                if (NS_FAILED(UpdateNextSctpInputStreamId()))
+                    mInput.OnSocketReady(NS_ERROR_FAILURE);
+                else
+                    mInput.OnSocketReady(NS_OK);
+            }
+            else  // not SCTP
+#endif
             mInput.OnSocketReady(NS_OK);
         }
         // Update poll timeout in case it was changed
         mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     }
     else if (mState == STATE_CONNECTING) {
 
         // We use PRIntervalTime here because we need
@@ -1909,16 +2222,21 @@ nsSocketTransport::OnSocketReady(PRFileD
         }
 
         if (status == PR_SUCCESS) {
             //
             // we are connected!
             //
             OnSocketConnected();
 
+            OnSocketConnected();
+#if defined(ENABLE_SCTP)
+            if (NS_FAILED(SetNumberOfOutgoingSctpStreams(fd)))
+                mInput.OnSocketReady(NS_ERROR_FAILURE);
+#endif
             if (mSocketTransportService->IsTelemetryEnabled()) {
                 if (mNetAddr.raw.family == AF_INET) {
                     Telemetry::Accumulate(
                         Telemetry::IPV4_AND_IPV6_ADDRESS_CONNECTIVITY,
                         SUCCESSFUL_CONNECTING_TO_IPV4_ADDRESS);
                 } else if (mNetAddr.raw.family == AF_INET6) {
                     Telemetry::Accumulate(
                         Telemetry::IPV4_AND_IPV6_ADDRESS_CONNECTIVITY,
@@ -2253,21 +2571,32 @@ nsSocketTransport::IsAlive(bool *result)
     PRFileDescAutoLock fd(this, &conditionWhileLocked);
     if (NS_FAILED(conditionWhileLocked) || !fd.IsInitialized()) {
         return NS_OK;
     }
 
     // XXX do some idle-time based checks??
 
     char c;
-    int32_t rval = PR_Recv(fd, &c, 1, PR_MSG_PEEK, 0);
-
-    if ((rval > 0) || (rval < 0 && PR_GetError() == PR_WOULD_BLOCK_ERROR))
-        *result = true;
-
+    int32_t rval;
+
+#if defined(ENABLE_SCTP)
+    if (PR_GetDescType(PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER)) ==
+                PR_DESC_SOCKET_SCTP_ONE_TO_ONE) {
+        nsresult rv;
+        rv = UpdateNextSctpInputStreamId();
+        if (NS_SUCCEEDED(rv) || rv == NS_BASE_STREAM_WOULD_BLOCK)
+            *result = true;
+    }
+    else
+#endif
+
+        if (((rval = PR_Recv(fd, &c, 1, PR_MSG_PEEK, 0)) > 0) ||
+            (rval < 0 && PR_GetError() == PR_WOULD_BLOCK_ERROR))
+            *result = true;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::GetHost(nsACString &host)
 {
     host = SocketHost();
     return NS_OK;
@@ -2590,33 +2919,36 @@ nsSocketTransport::SetConnectionFlags(ui
     mConnectionFlags = value;
     mIsPrivate = value & nsISocketTransport::NO_PERMANENT_STORAGE;
     return NS_OK;
 }
 
 void
 nsSocketTransport::OnKeepaliveEnabledPrefChange(bool aEnabled)
 {
+#ifndef ENABLE_SCTP
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 
     // The global pref toggles keepalive as a system feature; it only affects
     // an individual socket if keepalive has been specifically enabled for it.
     // So, ensure keepalive is configured correctly if previously enabled.
     if (mKeepaliveEnabled) {
         nsresult rv = SetKeepaliveEnabledInternal(aEnabled);
         if (NS_WARN_IF(NS_FAILED(rv))) {
             SOCKET_LOG(("  SetKeepaliveEnabledInternal [%s] failed rv[0x%x]",
                         aEnabled ? "enable" : "disable", rv));
         }
     }
+#endif
 }
 
 nsresult
 nsSocketTransport::SetKeepaliveEnabledInternal(bool aEnable)
 {
+#ifndef ENABLE_SCTP
     MOZ_ASSERT(mKeepaliveIdleTimeS > 0 &&
                mKeepaliveIdleTimeS <= kMaxTCPKeepIdle);
     MOZ_ASSERT(mKeepaliveRetryIntervalS > 0 &&
                mKeepaliveRetryIntervalS <= kMaxTCPKeepIntvl);
     MOZ_ASSERT(mKeepaliveProbeCount > 0 &&
                mKeepaliveProbeCount <= kMaxTCPKeepCount);
 
     PRFileDescAutoLock fd(this);
@@ -2635,31 +2967,35 @@ nsSocketTransport::SetKeepaliveEnabledIn
         SOCKET_LOG(("  SetKeepaliveVals failed rv[0x%x]", rv));
         return rv;
     }
     rv = fd.SetKeepaliveEnabled(enable);
     if (NS_WARN_IF(NS_FAILED(rv))) {
         SOCKET_LOG(("  SetKeepaliveEnabled failed rv[0x%x]", rv));
         return rv;
     }
+#endif
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::GetKeepaliveEnabled(bool *aResult)
 {
+#ifndef ENABLE_SCTP
     MOZ_ASSERT(aResult);
 
     *aResult = mKeepaliveEnabled;
+#endif
     return NS_OK;
 }
 
 nsresult
 nsSocketTransport::EnsureKeepaliveValsAreInitialized()
 {
+#ifndef ENABLE_SCTP
     nsresult rv = NS_OK;
     int32_t val = -1;
     if (mKeepaliveIdleTimeS == -1) {
         rv = mSocketTransportService->GetKeepaliveIdleTime(&val);
         if (NS_WARN_IF(NS_FAILED(rv))) {
             return rv;
         }
         mKeepaliveIdleTimeS = val;
@@ -2673,22 +3009,24 @@ nsSocketTransport::EnsureKeepaliveValsAr
     }
     if (mKeepaliveProbeCount == -1) {
         rv = mSocketTransportService->GetKeepaliveProbeCount(&val);
         if (NS_WARN_IF(NS_FAILED(rv))) {
             return rv;
         }
         mKeepaliveProbeCount = val;
     }
+#endif
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::SetKeepaliveEnabled(bool aEnable)
 {
+#ifndef ENABLE_SCTP
 #if defined(XP_WIN) || defined(XP_UNIX) || defined(XP_MACOSX)
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 
     if (aEnable == mKeepaliveEnabled) {
         SOCKET_LOG(("nsSocketTransport::SetKeepaliveEnabled [%p] already %s.",
                     this, aEnable ? "enabled" : "disabled"));
         return NS_OK;
     }
@@ -2723,22 +3061,25 @@ nsSocketTransport::SetKeepaliveEnabled(b
         return rv;
     }
 
     return NS_OK;
 #else /* !(defined(XP_WIN) || defined(XP_UNIX) || defined(XP_MACOSX)) */
     SOCKET_LOG(("nsSocketTransport::SetKeepaliveEnabled unsupported platform"));
     return NS_ERROR_NOT_IMPLEMENTED;
 #endif
+#endif
+    return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::SetKeepaliveVals(int32_t aIdleTime,
                                     int32_t aRetryInterval)
 {
+#ifndef ENABLE_SCTP
 #if defined(XP_WIN) || defined(XP_UNIX) || defined(XP_MACOSX)
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread, "wrong thread");
     if (NS_WARN_IF(aIdleTime <= 0 || kMaxTCPKeepIdle < aIdleTime)) {
         return NS_ERROR_INVALID_ARG;
     }
     if (NS_WARN_IF(aRetryInterval <= 0 ||
                    kMaxTCPKeepIntvl < aRetryInterval)) {
         return NS_ERROR_INVALID_ARG;
@@ -2784,16 +3125,19 @@ nsSocketTransport::SetKeepaliveVals(int3
     if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
     }
     return NS_OK;
 #else
     SOCKET_LOG(("nsSocketTransport::SetKeepaliveVals unsupported platform"));
     return NS_ERROR_NOT_IMPLEMENTED;
 #endif
+#endif
+    SOCKET_LOG(("nsSocketTransport::SetKeepaliveVals unsupported protocol"));
+    return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 #ifdef ENABLE_SOCKET_TRACING
 
 #include <stdio.h>
 #include <ctype.h>
 #include "prenv.h"
 
diff --git a/netwerk/base/nsSocketTransport2.h b/netwerk/base/nsSocketTransport2.h
--- a/netwerk/base/nsSocketTransport2.h
+++ b/netwerk/base/nsSocketTransport2.h
@@ -371,16 +371,26 @@ private:
     nsSocketOutputStream mOutput;
 
     friend class nsSocketInputStream;
     friend class nsSocketOutputStream;
 
     // socket timeouts are not protected by any lock.
     uint16_t mTimeouts[2];
 
+#if defined(ENABLE_SCTP)
+        // SCTP Stream Id tracking information
+    int32_t  mNextSctpInputStreamId;   // Need to allow -1 as a legitimate value
+    uint16_t mNextSctpOutputStreamId;
+    uint16_t mNumberOfSctpStreams;
+
+    // Method to peek for SCTP stream id of next SCTP message to be read.
+    nsresult UpdateNextSctpInputStreamId();
+    nsresult SetNumberOfOutgoingSctpStreams(PRFileDesc *fd);
+#endif
     // QoS setting for socket
     uint8_t mQoSBits;
 
     //
     // mFD access methods: called with mLock held.
     //
     PRFileDesc *GetFD_Locked();
     void        ReleaseFD_Locked(PRFileDesc *fd);
diff --git a/netwerk/base/nsSocketTransportService2.cpp b/netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp
+++ b/netwerk/base/nsSocketTransportService2.cpp
@@ -36,16 +36,19 @@ LazyLogModule gUDPSocketLog("UDPSocket")
 nsSocketTransportService *gSocketTransportService = nullptr;
 Atomic<PRThread*, Relaxed> gSocketThread;
 
 #define SEND_BUFFER_PREF "network.tcp.sendbuffer"
 #define KEEPALIVE_ENABLED_PREF "network.tcp.keepalive.enabled"
 #define KEEPALIVE_IDLE_TIME_PREF "network.tcp.keepalive.idle_time"
 #define KEEPALIVE_RETRY_INTERVAL_PREF "network.tcp.keepalive.retry_interval"
 #define KEEPALIVE_PROBE_COUNT_PREF "network.tcp.keepalive.probe_count"
+#if defined(ENABLE_SCTP)
+#define MAX_NUM_SCTP_STREAMS "network.http.sctp.max-number-of-outgoing-streams"
+#endif
 #define SOCKET_LIMIT_TARGET 550U
 #define SOCKET_LIMIT_MIN     50U
 #define BLIP_INTERVAL_PREF "network.activity.blipIntervalMilliseconds"
 #define MAX_TIME_BETWEEN_TWO_POLLS "network.sts.max_time_for_events_between_two_polls"
 #define TELEMETRY_PREF "toolkit.telemetry.enabled"
 
 uint32_t nsSocketTransportService::gMaxCount;
 PRCallOnceType nsSocketTransportService::gMaxCountInitOnce;
@@ -544,16 +547,19 @@ nsSocketTransportService::Init()
     if (tmpPrefService) {
         tmpPrefService->AddObserver(SEND_BUFFER_PREF, this, false);
         tmpPrefService->AddObserver(KEEPALIVE_ENABLED_PREF, this, false);
         tmpPrefService->AddObserver(KEEPALIVE_IDLE_TIME_PREF, this, false);
         tmpPrefService->AddObserver(KEEPALIVE_RETRY_INTERVAL_PREF, this, false);
         tmpPrefService->AddObserver(KEEPALIVE_PROBE_COUNT_PREF, this, false);
         tmpPrefService->AddObserver(MAX_TIME_BETWEEN_TWO_POLLS, this, false);
         tmpPrefService->AddObserver(TELEMETRY_PREF, this, false);
+#if defined(ENABLE_SCTP)
+        tmpPrefService->AddObserver(MAX_NUM_SCTP_STREAMS, this, false);
+#endif
     }
     UpdatePrefs();
 
     nsCOMPtr<nsIObserverService> obsSvc = services::GetObserverService();
     if (obsSvc) {
         obsSvc->AddObserver(this, "profile-initial-state", false);
         obsSvc->AddObserver(this, "last-pb-context-exited", false);
     }
@@ -669,16 +675,29 @@ nsSocketTransportService::GetKeepalivePr
     MOZ_ASSERT(aKeepaliveProbeCount);
     if (NS_WARN_IF(!aKeepaliveProbeCount)) {
         return NS_ERROR_NULL_POINTER;
     }
     *aKeepaliveProbeCount = mKeepaliveProbeCount;
     return NS_OK;
 }
 
+#if defined(ENABLE_SCTP)
+NS_IMETHODIMP
+nsSocketTransportService::GetMaxNumberOfSctpStreams(int32_t *aNumberOfSctpStreams)
+{
+    MOZ_ASSERT(aNumberOfSctpStreams);
+    if (NS_WARN_IF(!aNumberOfSctpStreams)) {
+        return NS_ERROR_NULL_POINTER;
+    }
+    *aNumberOfSctpStreams = mNumberOfSctpStreams;
+    return NS_OK;
+}
+#endif
+
 NS_IMETHODIMP
 nsSocketTransportService::CreateTransport(const char **types,
                                           uint32_t typeCount,
                                           const nsACString &host,
                                           int32_t port,
                                           nsIProxyInfo *proxyInfo,
                                           nsISocketTransport **result)
 {
@@ -1182,16 +1201,24 @@ nsSocketTransportService::UpdatePrefs()
                                                1, kMaxTCPKeepIntvl);
 
         int32_t keepaliveProbeCount;
         rv = tmpPrefService->GetIntPref(KEEPALIVE_PROBE_COUNT_PREF,
                                         &keepaliveProbeCount);
         if (NS_SUCCEEDED(rv))
             mKeepaliveProbeCount = clamped(keepaliveProbeCount,
                                            1, kMaxTCPKeepCount);
+#if defined(ENABLE_SCTP)
+        int32_t maxNumSctpStreams;
+        rv = tmpPrefService->GetIntPref(MAX_NUM_SCTP_STREAMS,
+                                        &maxNumSctpStreams);
+        if (NS_SUCCEEDED(rv))
+            mNumberOfSctpStreams = clamped(maxNumSctpStreams,
+                                           1, kMaxSCTPNumStreams);
+#endif
         bool keepaliveEnabled = false;
         rv = tmpPrefService->GetBoolPref(KEEPALIVE_ENABLED_PREF,
                                          &keepaliveEnabled);
         if (NS_SUCCEEDED(rv) && keepaliveEnabled != mKeepaliveEnabledPref) {
             mKeepaliveEnabledPref = keepaliveEnabled;
             OnKeepaliveEnabledPrefChange();
         }
 
diff --git a/netwerk/base/nsSocketTransportService2.h b/netwerk/base/nsSocketTransportService2.h
--- a/netwerk/base/nsSocketTransportService2.h
+++ b/netwerk/base/nsSocketTransportService2.h
@@ -46,16 +46,19 @@ extern mozilla::LazyLogModule gUDPSocket
 //-----------------------------------------------------------------------------
 
 namespace mozilla {
 namespace net {
 // These maximums are borrowed from the linux kernel.
 static const int32_t kMaxTCPKeepIdle  = 32767; // ~9 hours.
 static const int32_t kMaxTCPKeepIntvl = 32767;
 static const int32_t kMaxTCPKeepCount   = 127;
+#if defined(ENABLE_SCTP)
+static const int32_t kMaxSCTPNumStreams = 65535;
+#endif
 static const int32_t kDefaultTCPKeepCount =
 #if defined (XP_WIN)
                                               10; // Hardcoded in Windows.
 #elif defined (XP_MACOSX)
                                               8;  // Hardcoded in OSX.
 #else
                                               4;  // Specifiable in Linux.
 #endif
@@ -110,16 +113,19 @@ public:
     void GetSocketConnections(nsTArray<mozilla::net::SocketInfo> *);
     uint64_t GetSentBytes() { return mSentBytesCount; }
     uint64_t GetReceivedBytes() { return mReceivedBytesCount; }
 
     // Returns true if keepalives are enabled in prefs.
     bool IsKeepaliveEnabled() { return mKeepaliveEnabledPref; }
 
     bool IsTelemetryEnabled() { return mTelemetryEnabledPref; }
+#if defined(ENABLE_SCTP)
+    NS_IMETHODIMP GetMaxNumberOfSctpStreams(int32_t *aNumberOfSctpStreams);
+#endif
 protected:
 
     virtual ~nsSocketTransportService();
 
 private:
 
     //-------------------------------------------------------------------------
     // misc (any thread)
@@ -232,16 +238,20 @@ private:
     int32_t     mKeepaliveIdleTimeS;
     // Number of seconds between retries should keepalive pings fail.
     int32_t     mKeepaliveRetryIntervalS;
     // Number of keepalive probes to send.
     int32_t     mKeepaliveProbeCount;
     // True if TCP keepalive is enabled globally.
     bool        mKeepaliveEnabledPref;
 
+#if defined(ENABLE_SCTP)
+    uint16_t mNumberOfSctpStreams;
+#endif
+
     mozilla::Atomic<bool>  mServingPendingQueue;
     mozilla::Atomic<int32_t, mozilla::Relaxed> mMaxTimePerPollIter;
     mozilla::Atomic<bool, mozilla::Relaxed>  mTelemetryEnabledPref;
 
     void OnKeepaliveEnabledPrefChange();
     void NotifyKeepaliveEnabledPrefChange(SocketContext *sock);
 
     // Socket thread only for dynamically adjusting max socket size
diff --git a/netwerk/protocol/http/TunnelUtils.cpp b/netwerk/protocol/http/TunnelUtils.cpp
--- a/netwerk/protocol/http/TunnelUtils.cpp
+++ b/netwerk/protocol/http/TunnelUtils.cpp
@@ -1589,16 +1589,20 @@ FWD_TS_ADDREF(GetScriptablePeerAddr, nsI
 FWD_TS_ADDREF(GetScriptableSelfAddr, nsINetAddr);
 FWD_TS_ADDREF(GetSecurityInfo, nsISupports);
 FWD_TS_ADDREF(GetSecurityCallbacks, nsIInterfaceRequestor);
 FWD_TS_PTR(IsAlive, bool);
 FWD_TS_PTR(GetConnectionFlags, uint32_t);
 FWD_TS(SetConnectionFlags, uint32_t);
 FWD_TS_PTR(GetRecvBufferSize, uint32_t);
 FWD_TS(SetRecvBufferSize, uint32_t);
+FWD_TS_PTR(GetNextSctpInputStreamId, int32_t);
+FWD_TS_PTR(GetNextSctpOutputStreamId, int32_t);
+FWD_TS_PTR(GetNumberOfSctpStreams, int32_t);
+FWD_TS_PTR(IsSctpSocket, bool);
 
 NS_IMETHODIMP
 SocketTransportShim::GetHost(nsACString & aHost)
 {
   return mWrapped->GetHost(aHost);
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/protocol/http/nsAHttpTransaction.h b/netwerk/protocol/http/nsAHttpTransaction.h
--- a/netwerk/protocol/http/nsAHttpTransaction.h
+++ b/netwerk/protocol/http/nsAHttpTransaction.h
@@ -71,16 +71,23 @@ public:
     // called to read request data from the transaction.
     virtual nsresult ReadSegments(nsAHttpSegmentReader *reader,
                                   uint32_t count, uint32_t *countRead) = 0;
 
     // called to write response data to the transaction.
     virtual nsresult WriteSegments(nsAHttpSegmentWriter *writer,
                                    uint32_t count, uint32_t *countWritten) = 0;
 
+#if defined(ENABLE_SCTP)
+    // Called to write response data to the transaction, and pass transaction.
+    virtual nsresult WriteSegments(nsAHttpSegmentWriter *writer,
+                                   uint32_t count, uint32_t *countWritten,
+                                   nsAHttpTransaction *trans) { return NS_ERROR_FAILURE; };
+#endif
+
     // called to close the transaction
     virtual void Close(nsresult reason) = 0;
 
     // called to indicate a failure with proxy CONNECT
     virtual void SetProxyConnectFailed() = 0;
 
     // called to retrieve the request headers of the transaction
     virtual nsHttpRequestHead *RequestHead() = 0;
@@ -189,16 +196,17 @@ public:
     }
 
     virtual void DisableSpdy() { }
     virtual void ReuseConnectionOnRestartOK(bool) { }
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpTransaction, NS_AHTTPTRANSACTION_IID)
 
+#ifdef ENABLE_SCTP
 #define NS_DECL_NSAHTTPTRANSACTION \
     void SetConnection(nsAHttpConnection *) override; \
     nsAHttpConnection *Connection() override; \
     void GetSecurityCallbacks(nsIInterfaceRequestor **) override;       \
     void OnTransportStatus(nsITransport* transport, \
                            nsresult status, int64_t progress) override; \
     bool     IsDone() override; \
     nsresult Status() override; \
@@ -212,16 +220,41 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpTra
     void     SetProxyConnectFailed() override;                                   \
     virtual nsHttpRequestHead *RequestHead() override;                                   \
     uint32_t Http1xTransactionCount() override;                                  \
     nsresult TakeSubTransactions(nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions) override; \
     nsresult AddTransaction(nsAHttpTransaction *) override;                      \
     uint32_t PipelineDepth() override;                                           \
     nsresult SetPipelinePosition(int32_t) override;                              \
     int32_t  PipelinePosition() override;
+#else
+#define NS_DECL_NSAHTTPTRANSACTION \
+    void SetConnection(nsAHttpConnection *) override; \
+    nsAHttpConnection *Connection() override; \
+    void GetSecurityCallbacks(nsIInterfaceRequestor **) override;       \
+    void OnTransportStatus(nsITransport* transport, \
+                           nsresult status, int64_t progress) override; \
+    bool     IsDone() override; \
+    nsresult Status() override; \
+    uint32_t Caps() override;   \
+    void     SetDNSWasRefreshed() override; \
+    uint64_t Available() override; \
+    virtual nsresult ReadSegments(nsAHttpSegmentReader *, uint32_t, uint32_t *) override; \
+    virtual nsresult WriteSegments(nsAHttpSegmentWriter *, uint32_t, uint32_t *) override; \
+    virtual void Close(nsresult reason) override;                                \
+    nsHttpConnectionInfo *ConnectionInfo() override;                             \
+    void     SetProxyConnectFailed() override;                                   \
+    virtual nsHttpRequestHead *RequestHead() override;                                   \
+    uint32_t Http1xTransactionCount() override;                                  \
+    nsresult TakeSubTransactions(nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions) override; \
+    nsresult AddTransaction(nsAHttpTransaction *) override;                      \
+    uint32_t PipelineDepth() override;                                           \
+    nsresult SetPipelinePosition(int32_t) override;                              \
+    int32_t  PipelinePosition() override;
+#endif
 
 //-----------------------------------------------------------------------------
 // nsAHttpSegmentReader
 //-----------------------------------------------------------------------------
 
 class nsAHttpSegmentReader
 {
 public:
@@ -239,18 +272,32 @@ public:
     // commitment now but might in the future and forceCommitment is not true .
     // (forceCommitment requires a hard failure or OK at this moment.)
     //
     // SpdySession uses this to make sure frames are atomic.
     virtual nsresult CommitToSegmentSize(uint32_t size, bool forceCommitment)
     {
         return NS_ERROR_FAILURE;
     }
+
+#if defined(ENABLE_SCTP)
+    // Pass transaction via OnReadSegment
+    virtual nsresult OnReadSegment(const char *segment,
+                                   uint32_t count,
+                                   uint32_t *countRead,
+                                   nsAHttpTransaction *trans) { return NS_ERROR_FAILURE; };
+
+    // nsHttpPipeline::FillSendBuf needs to know if nsHttpConnection is using an SCTP socket.
+//  virtual bool IsSctpSocket(){ printf("nsAHttpSegmentReader IsSctpSocket?\n"); return  false; };
+virtual bool IsSctpSocket() { return false; };
+#endif
+
 };
 
+
 #define NS_DECL_NSAHTTPSEGMENTREADER \
     nsresult OnReadSegment(const char *, uint32_t, uint32_t *) override;
 
 //-----------------------------------------------------------------------------
 // nsAHttpSegmentWriter
 //-----------------------------------------------------------------------------
 
 class nsAHttpSegmentWriter
diff --git a/netwerk/protocol/http/nsHttpConnection.cpp b/netwerk/protocol/http/nsHttpConnection.cpp
--- a/netwerk/protocol/http/nsHttpConnection.cpp
+++ b/netwerk/protocol/http/nsHttpConnection.cpp
@@ -73,30 +73,52 @@ nsHttpConnection::nsHttpConnection()
     , mUsingSpdyVersion(0)
     , mPriority(nsISupportsPriority::PRIORITY_NORMAL)
     , mReportedSpdy(false)
     , mEverUsedSpdy(false)
     , mLastHttpResponseVersion(NS_HTTP_VERSION_1_1)
     , mTransactionCaps(0)
     , mResponseTimeoutEnabled(false)
     , mTCPKeepaliveConfig(kTCPKeepaliveDisabled)
+#if defined(ENABLE_SCTP)
+    , mNumberOfSctpStreams(0)
+    , mNextSctpInputStreamId(-1)
+#endif
     , mForceSendPending(false)
 {
     LOG(("Creating nsHttpConnection @%p\n", this));
 
     // the default timeout is for when this connection has not yet processed a
     // transaction
     static const PRIntervalTime k5Sec = PR_SecondsToInterval(5);
     mIdleTimeout =
         (k5Sec < gHttpHandler->IdleTimeout()) ? k5Sec : gHttpHandler->IdleTimeout();
 }
 
 nsHttpConnection::~nsHttpConnection()
 {
     LOG(("Destroying nsHttpConnection @%p\n", this));
+#if defined(ENABLE_SCTP)
+    for (int32_t i=mNumberOfSctpStreams-1; i>=0; i--) {
+        nsTArray<RefPtr<nsAHttpTransaction>> list;
+        list = static_cast<nsTArray<RefPtr<nsAHttpTransaction>>>
+                     (mStreamTransactionTable.ElementAt(i));
+        if (list.IsEmpty()) {
+            continue;
+        } else {
+            while (!list.IsEmpty()) {
+                nsAHttpTransaction *thisTrans;
+                thisTrans = (nsAHttpTransaction*)list.ElementAt(0);
+                if (thisTrans) {
+                    list.RemoveElementAt(0);
+                }
+            }
+        }
+    }   
+#endif
 
     if (!mEverUsedSpdy) {
         LOG(("nsHttpConnection %p performed %d HTTP/1.x transactions\n",
              this, mHttp1xTransactionCount));
         Telemetry::Accumulate(Telemetry::HTTP_REQUEST_PER_CONN,
                               mHttp1xTransactionCount);
     }
 
@@ -345,17 +367,16 @@ nsHttpConnection::OnTunnelNudged(TLSFilt
 
 // called on the socket thread
 nsresult
 nsHttpConnection::Activate(nsAHttpTransaction *trans, uint32_t caps, int32_t pri)
 {
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     LOG(("nsHttpConnection::Activate [this=%p trans=%x caps=%x]\n",
          this, trans, caps));
-
     if (!trans->IsNullTransaction())
         mExperienced = true;
 
     mTransactionCaps = caps;
     mPriority = pri;
     if (mTransaction && mUsingSpdyVersion) {
         return AddTransaction(trans, pri);
     }
@@ -1467,17 +1488,16 @@ nsHttpConnection::Version()
 // nsHttpConnection <private>
 //-----------------------------------------------------------------------------
 
 void
 nsHttpConnection::CloseTransaction(nsAHttpTransaction *trans, nsresult reason)
 {
     LOG(("nsHttpConnection::CloseTransaction[this=%p trans=%p reason=%x]\n",
         this, trans, reason));
-
     MOZ_ASSERT((trans == mTransaction) ||
                (mTLSFilter && mTLSFilter->Transaction() == trans));
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
 
     if (mCurrentBytesRead > mMaxBytesRead)
         mMaxBytesRead = mCurrentBytesRead;
 
     // mask this error code because its not a real error.
@@ -1548,22 +1568,54 @@ nsHttpConnection::OnReadSegment(const ch
         mSocketOutCondition = NS_OK; // reset condition
         if (!mProxyConnectInProgress)
             mTotalBytesWritten += *countRead;
     }
 
     return mSocketOutCondition;
 }
 
+#if defined(ENABLE_SCTP)
+nsresult
+nsHttpConnection::OnReadSegment(const char *buf,
+                                uint32_t count,
+                                uint32_t *countRead,
+                                nsAHttpTransaction *trans)
+{
+    if (count == 0) {
+        // some ReadSegments implementations will erroneously call the writer
+        // to consume 0 bytes worth of data.  we must protect against this case
+        // or else we'd end up closing the socket prematurely.
+        NS_ERROR("bad ReadSegments implementation");
+        return NS_ERROR_FAILURE; // stop iterating
+    }
+    // Must update mNextSctpOutputStreamId
+    int32_t sctpOutputStream;
+    nsresult sctpSocket = mSocketTransport->GetNextSctpOutputStreamId(&sctpOutputStream);
+    nsresult rv = mSocketOut->Write(buf, count, countRead);
+    if (NS_FAILED(rv)) {
+        mSocketOutCondition = rv;
+    } else if (*countRead == 0) {
+        mSocketOutCondition = NS_BASE_STREAM_CLOSED;
+    } else if (NS_SUCCEEDED(sctpSocket)) {
+        // Add this transaction to the SCTP stream transaction table
+        mSocketOutCondition = AddSctpTransaction(sctpOutputStream, trans);
+    } else {
+        mSocketOutCondition = NS_OK; // reset condition
+    }
+
+    return mSocketOutCondition;
+}
+#endif
+
 nsresult
 nsHttpConnection::OnSocketWritable()
 {
     LOG(("nsHttpConnection::OnSocketWritable [this=%p] host=%s\n",
          this, mConnInfo->Origin()));
-
     nsresult rv;
     uint32_t transactionBytes;
     bool again = true;
 
     do {
         rv = mSocketOutCondition = NS_OK;
         transactionBytes = 0;
 
@@ -1586,24 +1638,22 @@ nsHttpConnection::OnSocketWritable()
         } else {
 
             // for non spdy sessions let the connection manager know
             if (!mReportedSpdy) {
                 mReportedSpdy = true;
                 MOZ_ASSERT(!mEverUsedSpdy);
                 gHttpHandler->ConnMgr()->ReportSpdyConnection(this, false);
             }
-
-            LOG(("  writing transaction request stream\n"));
+            LOG(("  writing transaction request stream, read segments from pipeline\n"));
             mProxyConnectInProgress = false;
             rv = mTransaction->ReadSegments(this, nsIOService::gDefaultSegmentSize,
                                             &transactionBytes);
             mContentBytesWritten += transactionBytes;
         }
-
         LOG(("nsHttpConnection::OnSocketWritable %p "
              "ReadSegments returned [rv=%x read=%u sock-cond=%x]\n",
              this, rv, transactionBytes, mSocketOutCondition));
 
         // XXX some streams return NS_BASE_STREAM_CLOSED to indicate EOF.
         if (rv == NS_BASE_STREAM_CLOSED && !mTransaction->IsDone()) {
             rv = NS_OK;
             transactionBytes = 0;
@@ -1665,32 +1715,42 @@ nsHttpConnection::OnWriteSegment(char *b
     }
 
     if (ChaosMode::isActive(ChaosFeature::IOAmounts) &&
         ChaosMode::randomUint32LessThan(2)) {
         // read 1...count bytes
         count = ChaosMode::randomUint32LessThan(count) + 1;
     }
 
+#if defined(ENABLE_SCTP)
+    int32_t prevSctpInputStreamId = mNextSctpInputStreamId;
+#endif
     nsresult rv = mSocketIn->Read(buf, count, countWritten);
     if (NS_FAILED(rv))
         mSocketInCondition = rv;
     else if (*countWritten == 0)
         mSocketInCondition = NS_BASE_STREAM_CLOSED;
-    else
+    else {
         mSocketInCondition = NS_OK; // reset condition
 
+#if defined(ENABLE_SCTP)
+        // Will SCTP input stream id change on next read?
+        if (mSocketTransport->GetNextSctpInputStreamId(&mNextSctpInputStreamId) != NS_ERROR_INVALID_SOCKET_TYPE)
+            if (prevSctpInputStreamId != mNextSctpInputStreamId) {
+                return NS_SCTP_INPUT_STREAM_ID_CHANGED;
+            }
+#endif
+    }
     return mSocketInCondition;
 }
 
 nsresult
 nsHttpConnection::OnSocketReadable()
 {
     LOG(("nsHttpConnection::OnSocketReadable [this=%p]\n", this));
-
     PRIntervalTime now = PR_IntervalNow();
     PRIntervalTime delta = now - mLastReadTime;
 
     // Reset mResponseTimeoutEnabled to stop response timeout checks.
     mResponseTimeoutEnabled = false;
 
     if (mKeepAliveMask && (delta >= mMaxHangTime)) {
         LOG(("max hang time exceeded!\n"));
@@ -1714,17 +1774,16 @@ nsHttpConnection::OnSocketReadable()
         delta = 0;
 
     static const PRIntervalTime k400ms  = PR_MillisecondsToInterval(400);
 
     if (delta >= (mRtt + gHttpHandler->GetPipelineRescheduleTimeout())) {
         LOG(("Read delta ms of %u causing slow read major "
              "event and pipeline cancellation",
              PR_IntervalToMilliseconds(delta)));
-
         gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
             mConnInfo, nsHttpConnectionMgr::BadSlowReadMajor, this, 0);
 
         if (gHttpHandler->GetPipelineRescheduleOnTimeout() &&
             mTransaction->PipelineDepth() > 1) {
             nsHttpPipeline *pipeline = mTransaction->QueryPipeline();
             MOZ_ASSERT(pipeline, "pipelinedepth > 1 without pipeline");
             // code this defensively for the moment and check for null
@@ -1743,55 +1802,106 @@ nsHttpConnection::OnSocketReadable()
             mConnInfo, nsHttpConnectionMgr::BadSlowReadMinor, this, 0);
     }
 
     mLastReadTime = now;
 
     nsresult rv;
     uint32_t n;
     bool again = true;
+   
+#if defined(ENABLE_SCTP)
+    nsAHttpTransaction *thisTransaction;
+    int32_t thisSctpInputStreamId;
+    nsresult sctpSocket;
+#endif
 
     do {
         if (!mProxyConnectInProgress && !mNPNComplete) {
             // Unless we are setting up a tunnel via CONNECT, prevent reading
             // from the socket until the results of NPN
             // negotiation are known (which is determined from the write path).
             // If the server speaks SPDY it is likely the readable data here is
             // a spdy settings frame and without NPN it would be misinterpreted
-            // as HTTP/*
+            // as HTTP
 
             LOG(("nsHttpConnection::OnSocketReadable %p return due to inactive "
                  "tunnel setup but incomplete NPN state\n", this));
             rv = NS_OK;
             break;
         }
 
+#if defined(ENABLE_SCTP)
+        // Get valid SCTP stream id and update mSocketInCondition
+        sctpSocket = mSocketTransport->GetNextSctpInputStreamId(&mNextSctpInputStreamId);
+        if (sctpSocket != NS_ERROR_INVALID_SOCKET_TYPE) {
+            mSocketInCondition = sctpSocket;
+            if (NS_FAILED(mSocketInCondition)) {
+                // continue waiting for the socket if necessary...
+                if (mSocketInCondition == NS_BASE_STREAM_WOULD_BLOCK) {
+                    rv = mSocketIn->AsyncWait(this, 0, 0, nullptr);
+                } else
+                    rv = mSocketInCondition;
+                break;
+            }
+            GetHeadTransaction(mNextSctpInputStreamId, &thisTransaction);
+            if (!thisTransaction) {
+                return NS_ERROR_UNEXPECTED;
+            } else
+
+            thisSctpInputStreamId = mNextSctpInputStreamId;
+            if(thisTransaction != mTransaction) {
+                // mTransaction is a pipeline
+                rv = mTransaction->WriteSegments(this, nsIOService::gDefaultSegmentSize,
+                                                 &n, thisTransaction);
+                
+                // nsHttpPipeline::WriteSegments returns NS_BASE_STREAM_CLOSED when
+                // thisTransaction is complete and closed.  Delete transaction table
+                // entry here.
+                if (rv == NS_BASE_STREAM_CLOSED) {
+                    DeleteHeadTransaction(thisSctpInputStreamId);
+                    // if pipeline is not done, return NS_OK
+                    if (!(mTransaction->IsDone()))
+                        rv = NS_OK;
+                }
+            }
+  	        else {
+                rv = mTransaction->WriteSegments(this, nsIOService::gDefaultSegmentSize, &n);
+                // return NS_BASE_STREAM_CLOSED here to close an individual transaction
+                // and delete transaction table entry.
+                if (mTransaction->IsDone()) {
+                    DeleteHeadTransaction(thisSctpInputStreamId);
+                    rv = NS_BASE_STREAM_CLOSED;
+                }
+            }
+        }
+        else
+#endif
         rv = mTransaction->WriteSegments(this, nsIOService::gDefaultSegmentSize, &n);
+
         if (NS_FAILED(rv)) {
             // if the transaction didn't want to take any more data, then
             // wait for the transaction to call ResumeRecv.
             if (rv == NS_BASE_STREAM_WOULD_BLOCK)
                 rv = NS_OK;
             again = false;
-        }
-        else {
+        } else {
             mCurrentBytesRead += n;
             mTotalBytesRead += n;
             if (NS_FAILED(mSocketInCondition)) {
                 // continue waiting for the socket if necessary...
                 if (mSocketInCondition == NS_BASE_STREAM_WOULD_BLOCK)
                     rv = ResumeRecv();
                 else
                     rv = mSocketInCondition;
                 again = false;
             }
         }
         // read more from the socket until error...
     } while (again);
-
     return rv;
 }
 
 void
 nsHttpConnection::SetupSecondaryTLS()
 {
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     MOZ_ASSERT(!mTLSFilter);
@@ -2091,16 +2201,24 @@ nsHttpConnection::OnOutputStreamReady(ns
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     MOZ_ASSERT(out == mSocketOut, "unexpected socket");
     // if the transaction was dropped...
     if (!mTransaction) {
         LOG(("  no transaction; ignoring event\n"));
         return NS_OK;
     }
 
+#if defined(ENABLE_SCTP)
+    // Initialize stream transaction table if necessary
+    if (mNumberOfSctpStreams == 0)
+        if (mSocketTransport->GetNumberOfSctpStreams(&mNumberOfSctpStreams) !=
+            NS_ERROR_INVALID_SOCKET_TYPE)
+            InitializeStreamTransactionTable();
+#endif
+
     nsresult rv = OnSocketWritable();
     if (NS_FAILED(rv))
         CloseTransaction(mTransaction, rv);
 
     return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
@@ -2142,16 +2260,116 @@ nsHttpConnection::GetInterface(const nsI
         MutexAutoLock lock(mCallbacksLock);
         callbacks = mCallbacks;
     }
     if (callbacks)
         return callbacks->GetInterface(iid, result);
     return NS_ERROR_NO_INTERFACE;
 }
 
+//
+// Methods for maintaining the SCTP stream transaction table
+//
+//-----------------------------------------------------------------------------
+// nsHttpConnection::InitializeStreamTransactionTable
+//-----------------------------------------------------------------------------
+
+#if defined(ENABLE_SCTP)
+nsresult
+nsHttpConnection::InitializeStreamTransactionTable()	
+{
+    for (int32_t i=0; i<mNumberOfSctpStreams; i++) {
+        nsTArray<RefPtr<nsAHttpTransaction>> list;
+        mStreamTransactionTable.AppendElement(list);
+    }
+    return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
+// nsHttpConnection::AddSctpTransaction
+//-----------------------------------------------------------------------------
+NS_IMETHODIMP
+nsHttpConnection::AddSctpTransaction(int32_t aSctpStreamId, nsAHttpTransaction* aTrans)
+{
+    NS_ENSURE_ARG_POINTER(aTrans);
+    NS_ASSERTION(aSctpStreamId  > -1 && aSctpStreamId < mNumberOfSctpStreams,
+                 "AddSctpTransaction: Invalid SCTP Stream ID");
+    //std::list<nsAHttpTransaction*> *transList;
+    nsTArray<RefPtr<nsAHttpTransaction>> list;
+    list = static_cast<nsTArray<RefPtr<nsAHttpTransaction>>>
+                     (mStreamTransactionTable.ElementAt(aSctpStreamId));
+    list.AppendElement(aTrans);
+    mStreamTransactionTable.ReplaceElementAt(aSctpStreamId, list);
+    return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
+// nsHttpConnection::GetHeadTransaction
+//-----------------------------------------------------------------------------
+
+NS_IMETHODIMP
+nsHttpConnection::GetHeadTransaction(int32_t aSctpStreamId, nsAHttpTransaction** aTrans)
+{
+    NS_ASSERTION(aSctpStreamId > -1 && aSctpStreamId < mNumberOfSctpStreams,
+                 "GetHeadTransaction: Invalid SCTP Sttream ID");
+    *aTrans = nullptr;
+    nsTArray<RefPtr<nsAHttpTransaction>> list;
+    list = static_cast<nsTArray<RefPtr<nsAHttpTransaction>>>
+                     (mStreamTransactionTable.ElementAt(aSctpStreamId));
+    if (list.IsEmpty()) {
+        NS_ERROR("No transaction on this SCTP stream");
+    }
+    
+    *aTrans = (nsAHttpTransaction*)list.ElementAt(0);
+
+    if (!*aTrans)
+        NS_ERROR("No transaction on this SCTP stream");
+
+    return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
+// nsHttpConnection::DeleteHeadTransaction
+//-----------------------------------------------------------------------------
+
+NS_IMETHODIMP
+nsHttpConnection::DeleteHeadTransaction(int32_t aSctpStreamId)
+{
+    NS_ASSERTION(aSctpStreamId > -1 && aSctpStreamId < mNumberOfSctpStreams,
+                 "DeleteTransaction: Invalid SCTPStream ID");
+    nsTArray<RefPtr<nsAHttpTransaction>> list;
+    list = static_cast<nsTArray<RefPtr<nsAHttpTransaction>>>
+                     (mStreamTransactionTable.ElementAt(aSctpStreamId));
+    if (list.IsEmpty()) {
+        NS_ERROR("No transaction to delete on this SCTP stream");
+    } else {
+        nsAHttpTransaction *thisTrans;
+        thisTrans = (nsAHttpTransaction*)list.ElementAt(0);
+        if (thisTrans) {
+            list.RemoveElementAt(0);
+            mStreamTransactionTable.ReplaceElementAt(aSctpStreamId, list);
+        }
+    }
+    return NS_OK;
+}
+
+bool
+nsHttpConnection::IsSctpSocket()
+{
+    bool result;
+
+    result = false;
+
+    if (mSocketTransport)
+        mSocketTransport->IsSctpSocket(&result); 	
+
+    return result;
+}
+#endif
+
 void
 nsHttpConnection::CheckForTraffic(bool check)
 {
     if (check) {
         LOG((" CheckForTraffic conn %p\n", this));
         if (mSpdySession) {
             if (PR_IntervalToMilliseconds(IdleTime()) >= 500) {
                 // Send a ping to verify it is still alive if it has been idle
diff --git a/netwerk/protocol/http/nsHttpConnection.h b/netwerk/protocol/http/nsHttpConnection.h
--- a/netwerk/protocol/http/nsHttpConnection.h
+++ b/netwerk/protocol/http/nsHttpConnection.h
@@ -10,16 +10,18 @@
 #include "nsAHttpTransaction.h"
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsProxyRelease.h"
 #include "prinrval.h"
 #include "TunnelUtils.h"
 #include "mozilla/Mutex.h"
 #include "ARefBase.h"
+#include <list>
+#include <vector>
 
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsITimer.h"
 
 class nsISocketTransport;
 class nsISSLSocketControl;
@@ -212,16 +214,22 @@ public:
     // connection since CheckForTraffic() was called.
     bool NoTraffic() {
         return mTrafficStamp &&
             (mTrafficCount == (mTotalBytesWritten + mTotalBytesRead));
     }
     // override of nsAHttpConnection
     virtual uint32_t Version();
 
+#if defined(ENABLE_SCTP)
+    nsresult OnReadSegment(const char *buf, uint32_t count, uint32_t *countRead,
+                                nsAHttpTransaction *trans) override;
+    bool IsSctpSocket() override;
+#endif
+
 private:
     // Value (set in mTCPKeepaliveConfig) indicates which set of prefs to use.
     enum TCPKeepaliveConfig {
       kTCPKeepaliveDisabled = 0,
       kTCPKeepaliveShortLivedConfig,
       kTCPKeepaliveLongLivedConfig
     };
 
@@ -345,16 +353,29 @@ private:
     uint32_t                        mTransactionCaps;
 
     bool                            mResponseTimeoutEnabled;
 
     // Flag to indicate connection is in inital keepalive period (fast detect).
     uint32_t                        mTCPKeepaliveConfig;
     nsCOMPtr<nsITimer>              mTCPKeepaliveTransitionTimer;
 
+#if defined(ENABLE_SCTP)
+    // SCTP related members
+    nsTArray<nsTArray<RefPtr<nsAHttpTransaction>>> mStreamTransactionTable; // 2D array of stream numbers and the
+                                         //transactions assigned to them
+    int32_t     mNumberOfSctpStreams;
+    int32_t     mNextSctpInputStreamId;
+    nsresult    mSctpSocketInCondition;  // does the next message correspond
+                                         // to this transaction?
+    nsresult InitializeStreamTransactionTable();
+    nsresult AddSctpTransaction(PRInt32 aSctpStream, nsAHttpTransaction* aTrans);
+    nsresult GetHeadTransaction(PRInt32 aSctpStream, nsAHttpTransaction** aTrans);
+    nsresult DeleteHeadTransaction(PRInt32 aSctpStream);
+#endif
 private:
     // For ForceSend()
     static void                     ForceSendIO(nsITimer *aTimer, void *aClosure);
     nsresult                        MaybeForceSendIO();
     bool                            mForceSendPending;
     nsCOMPtr<nsITimer>              mForceSendTimer;
 };
 
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -325,17 +325,20 @@ nsHttpConnectionMgr::Observe(nsISupports
 
 
 //-----------------------------------------------------------------------------
 
 nsresult
 nsHttpConnectionMgr::AddTransaction(nsHttpTransaction *trans, int32_t priority)
 {
     LOG(("nsHttpConnectionMgr::AddTransaction [trans=%p %d]\n", trans, priority));
+    if (trans)
     return PostEvent(&nsHttpConnectionMgr::OnMsgNewTransaction, priority, trans);
+    else
+    return NS_ERROR_FAILURE;
 }
 
 nsresult
 nsHttpConnectionMgr::RescheduleTransaction(nsHttpTransaction *trans, int32_t priority)
 {
     LOG(("nsHttpConnectionMgr::RescheduleTransaction [trans=%p %d]\n", trans, priority));
     return PostEvent(&nsHttpConnectionMgr::OnMsgReschedTransaction, priority, trans);
 }
@@ -1655,24 +1658,23 @@ nsHttpConnectionMgr::TryDispatchTransact
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     LOG(("nsHttpConnectionMgr::TryDispatchTransaction without conn "
          "[trans=%p ci=%p ci=%s caps=%x tunnelprovider=%p onlyreused=%d "
          "active=%d idle=%d]\n", trans,
          ent->mConnInfo.get(), ent->mConnInfo->HashKey().get(),
          uint32_t(trans->Caps()), trans->TunnelProvider(),
          onlyReusedConnection, ent->mActiveConns.Length(),
          ent->mIdleConns.Length()));
-
     nsHttpTransaction::Classifier classification = trans->Classification();
     uint32_t caps = trans->Caps();
 
     // no keep-alive means no pipelines either
-    if (!(caps & NS_HTTP_ALLOW_KEEPALIVE))
+    if (!(caps & NS_HTTP_ALLOW_KEEPALIVE)) {
         caps = caps & ~NS_HTTP_ALLOW_PIPELINING;
-
+    }
     // 0 - If this should use spdy then dispatch it post haste.
     // 1 - If there is connection pressure then see if we can pipeline this on
     //     a connection of a matching type instead of using a new conn
     // 2 - If there is an idle connection, use it!
     // 3 - if class == reval or script and there is an open conn of that type
     //     then pipeline onto shortest pipeline of that class if limits allow
     // 4 - If we aren't up against our connection limit,
     //     then open a new one
@@ -1865,17 +1867,16 @@ nsHttpConnectionMgr::DispatchTransaction
 {
     uint32_t caps = trans->Caps();
     int32_t priority = trans->Priority();
     nsresult rv;
 
     LOG(("nsHttpConnectionMgr::DispatchTransaction "
          "[ent-ci=%s %p trans=%p caps=%x conn=%p priority=%d]\n",
          ent->mConnInfo->HashKey().get(), ent, trans, caps, conn, priority));
-
     // It is possible for a rate-paced transaction to be dispatched independent
     // of the token bucket when the amount of parallelization has changed or
     // when a muxed connection (e.g. spdy or pipelines) becomes available.
     trans->CancelPacing(NS_OK);
 
     if (conn->UsingSpdy()) {
         LOG(("Spdy Dispatch Transaction via Activate(). Transaction host = %s, "
              "Connection host = %s\n",
@@ -1963,17 +1964,16 @@ nsHttpConnectionMgr::DispatchAbstractTra
                                                  nsHttpConnection *conn,
                                                  int32_t priority)
 {
     MOZ_ASSERT(!conn->UsingSpdy(),
                "Spdy Must Not Use DispatchAbstractTransaction");
     LOG(("nsHttpConnectionMgr::DispatchAbstractTransaction "
          "[ci=%s trans=%p caps=%x conn=%p]\n",
          ent->mConnInfo->HashKey().get(), aTrans, caps, conn));
-
     /* Use pipeline datastructure even if connection does not currently qualify
        to pipeline this transaction because a different pipeline-eligible
        transaction might be placed on the active connection. Make an exception
        for CLASS_SOLO as that connection will never pipeline until it goes
        quiescent */
 
     RefPtr<nsAHttpTransaction> transaction;
     nsresult rv;
@@ -2053,17 +2053,16 @@ nsHttpConnectionMgr::ReportProxyTelemetr
     else
         Telemetry::Accumulate(Telemetry::HTTP_PROXY_TYPE, PROXY_SOCKS);
 }
 
 nsresult
 nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans)
 {
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
-
     // since "adds" and "cancels" are processed asynchronously and because
     // various events might trigger an "add" directly on the socket thread,
     // we must take care to avoid dispatching a transaction that has already
     // been canceled (see bug 190001).
     if (NS_FAILED(trans->Status())) {
         LOG(("  transaction was canceled... dropping event!\n"));
         return NS_OK;
     }
@@ -2358,17 +2357,16 @@ nsHttpConnectionMgr::OnMsgShutdownConfir
     BoolWrapper *shutdown = static_cast<BoolWrapper *>(param);
     shutdown->mBool = true;
 }
 
 void
 nsHttpConnectionMgr::OnMsgNewTransaction(int32_t priority, ARefBase *param)
 {
     LOG(("nsHttpConnectionMgr::OnMsgNewTransaction [trans=%p]\n", param));
-
     nsHttpTransaction *trans = static_cast<nsHttpTransaction *>(param);
     trans->SetPriority(priority);
     nsresult rv = ProcessNewTransaction(trans);
     if (NS_FAILED(rv))
         trans->Close(rv); // for whatever its worth
 }
 
 void
diff --git a/netwerk/protocol/http/nsHttpPipeline.cpp b/netwerk/protocol/http/nsHttpPipeline.cpp
--- a/netwerk/protocol/http/nsHttpPipeline.cpp
+++ b/netwerk/protocol/http/nsHttpPipeline.cpp
@@ -84,17 +84,16 @@ nsHttpPipeline::~nsHttpPipeline()
     if (mPushBackBuf)
         free(mPushBackBuf);
 }
 
 nsresult
 nsHttpPipeline::AddTransaction(nsAHttpTransaction *trans)
 {
     LOG(("nsHttpPipeline::AddTransaction [this=%p trans=%x]\n", this, trans));
-
     if (mRequestQ.Length() || mResponseQ.Length())
         mUtilizedPipeline = true;
 
     NS_ADDREF(trans);
     mRequestQ.AppendElement(trans);
     uint32_t qlen = PipelineDepth();
 
     if (qlen != 1) {
@@ -220,18 +219,19 @@ nsHttpPipeline::CloseTransaction(nsAHttp
             // the transaction is in the request queue.  check to see if any of
             // its data has been written out yet.
             killPipeline = true;
         }
         mRequestQ.RemoveElementAt(index);
     }
     else {
         index = mResponseQ.IndexOf(trans);
-        if (index >= 0)
+        if (index >= 0) {
             mResponseQ.RemoveElementAt(index);
+        }
         // while we could avoid killing the pipeline if this transaction is the
         // last transaction in the pipeline, there doesn't seem to be that much
         // value in doing so.  most likely if this transaction is going away,
         // the others will be shortly as well.
         killPipeline = true;
     }
 
     // Marking this connection as non-reusable prevents other items from being
@@ -353,17 +353,16 @@ nsHttpPipeline::SetProxyConnectFailed()
     if (trans)
         trans->SetProxyConnectFailed();
 }
 
 nsHttpRequestHead *
 nsHttpPipeline::RequestHead()
 {
     nsAHttpTransaction *trans = Request(0);
-
     if (trans)
         return trans->RequestHead();
     return nullptr;
 }
 
 uint32_t
 nsHttpPipeline::Http1xTransactionCount()
 {
@@ -593,40 +592,49 @@ NS_METHOD
 nsHttpPipeline::ReadFromPipe(nsIInputStream *stream,
                              void *closure,
                              const char *buf,
                              uint32_t offset,
                              uint32_t count,
                              uint32_t *countRead)
 {
     nsHttpPipeline *self = (nsHttpPipeline *) closure;
+#if defined(ENABLE_SCTP)
+    // Pass transaction for maintaining SCTP stream transaction table
+    return self->mReader->OnReadSegment(buf, count, countRead,
+                                        self->mCurrentReadTransaction);
+#else
     return self->mReader->OnReadSegment(buf, count, countRead);
+#endif
+    return NS_OK;
 }
 
 nsresult
 nsHttpPipeline::ReadSegments(nsAHttpSegmentReader *reader,
                              uint32_t count,
                              uint32_t *countRead)
 {
     LOG(("nsHttpPipeline::ReadSegments [this=%p count=%u]\n", this, count));
-
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
 
     if (mClosed) {
         *countRead = 0;
         return mStatus;
     }
 
     nsresult rv;
     uint64_t avail = 0;
     if (mSendBufIn) {
         rv = mSendBufIn->Available(&avail);
         if (NS_FAILED(rv)) return rv;
     }
 
+    // FillSendBuf needs mReader to be initialized
+    mReader = reader;
+
     if (avail == 0) {
         rv = FillSendBuf();
         if (NS_FAILED(rv)) return rv;
 
         rv = mSendBufIn->Available(&avail);
         if (NS_FAILED(rv)) return rv;
 
         // return EOF if send buffer is empty
@@ -635,32 +643,29 @@ nsHttpPipeline::ReadSegments(nsAHttpSegm
             return NS_OK;
         }
     }
 
     // read no more than what was requested
     if (avail > count)
         avail = count;
 
-    mReader = reader;
-
     // avail is under 4GB, so casting to uint32_t is safe
     rv = mSendBufIn->ReadSegments(ReadFromPipe, this, (uint32_t)avail, countRead);
 
     mReader = nullptr;
     return rv;
 }
 
 nsresult
 nsHttpPipeline::WriteSegments(nsAHttpSegmentWriter *writer,
                               uint32_t count,
                               uint32_t *countWritten)
 {
     LOG(("nsHttpPipeline::WriteSegments [this=%p count=%u]\n", this, count));
-
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
 
     if (mClosed)
         return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
 
     nsAHttpTransaction *trans;
     nsresult rv;
 
@@ -683,17 +688,16 @@ nsHttpPipeline::WriteSegments(nsAHttpSeg
             rv = NS_BASE_STREAM_CLOSED;
     }
     else {
         //
         // ask the transaction to consume data from the connection.
         // PushBack may be called recursively.
         //
         rv = trans->WriteSegments(writer, count, countWritten);
-
         if (rv == NS_BASE_STREAM_CLOSED || trans->IsDone()) {
             trans->Close(NS_OK);
 
             // Release the transaction if it is not IsProxyConnectInProgress()
             if (trans == Response(0)) {
                 NS_RELEASE(trans);
                 mResponseQ.RemoveElementAt(0);
                 mResponseIsPartial = false;
@@ -728,16 +732,67 @@ nsHttpPipeline::WriteSegments(nsAHttpSeg
         // so we are guaranteed that the next response will eat the entire
         // push back buffer (even though it might again call PushBack).
         rv = WriteSegments(&writer, len, &n);
     }
 
     return rv;
 }
 
+#if defined(ENABLE_SCTP)
+nsresult 	
+nsHttpPipeline::WriteSegments(nsAHttpSegmentWriter *writer,
+                              uint32_t count,
+                              uint32_t *countWritten,
+                              nsAHttpTransaction *trans)
+{
+    LOG(("nsHttpPipeline::WriteSegments [this=%x count=%u]\n", this, count));
+    NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
+
+    if (mClosed)
+        return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
+
+    nsresult rv;
+
+    NS_ASSERTION(trans, "Transaction should never be null here");
+
+
+    //
+    // ask the transaction to consume data from the connection. 	
+    // PushBack may be called recursively.
+    //
+    rv = trans->WriteSegments(writer, count, countWritten);
+    if (rv == NS_BASE_STREAM_CLOSED || trans->IsDone()) {
+        trans->Close(NS_OK);
+        rv = NS_BASE_STREAM_CLOSED;    // Notifies writer that trans is closed.
+        mResponseQ.RemoveElement(trans);
+        NS_RELEASE(trans);
+        mResponseIsPartial = false;
+
+        // ask the connection manager to add additional transactions
+        // to our pipeline.
+        gHttpHandler->ConnMgr()->AddTransaction((nsHttpTransaction *)trans, 0);
+    }
+    else
+        mResponseIsPartial = true;
+
+    if (mPushBackLen) {
+        nsHttpPushBackWriter writer(mPushBackBuf, mPushBackLen);
+        uint32_t len = mPushBackLen, n;
+        mPushBackLen = 0;
+        // the push back buffer is never larger than NS_HTTP_SEGMENT_SIZE,
+        // so we are guaranteed that the next response will eat the entire
+        // push back buffer (even though it might again call PushBack).
+        rv = WriteSegments(&writer, len, &n, trans);
+    }
+
+    return rv;
+}
+#endif
+
 uint32_t
 nsHttpPipeline::CancelPipeline(nsresult originalReason)
 {
     uint32_t i, reqLen, respLen, total;
     nsAHttpTransaction *trans;
 
     reqLen = mRequestQ.Length();
     respLen = mResponseQ.Length();
@@ -832,16 +887,29 @@ nsHttpPipeline::Close(nsresult reason)
 nsresult
 nsHttpPipeline::OnReadSegment(const char *segment,
                               uint32_t count,
                               uint32_t *countRead)
 {
     return mSendBufOut->Write(segment, count, countRead);
 }
 
+ 	
+#if defined(ENABLE_SCTP)
+nsresult
+nsHttpPipeline::OnReadSegment(const char *segment,
+                              uint32_t count,
+                              uint32_t *countRead,
+                              nsAHttpTransaction *trans)
+{
+    // just a wrapper for HttpPipeline
+    return mSendBufOut->Write(segment, count, countRead);
+}
+#endif
+
 nsresult
 nsHttpPipeline::FillSendBuf()
 {
     // reads from request queue, moving transactions to response queue
     // when they have been completely read.
 
     nsresult rv;
 
@@ -856,27 +924,42 @@ nsHttpPipeline::FillSendBuf()
     }
 
     uint32_t n;
     uint64_t avail;
     nsAHttpTransaction *trans;
     nsITransport *transport = Transport();
 
     while ((trans = Request(0)) != nullptr) {
+
+#if defined(ENABLE_SCTP)
+        mCurrentReadTransaction = trans;
+#endif
+
         avail = trans->Available();
         if (avail) {
             // if there is already a response in the responseq then this
             // new data comprises a pipeline. Update the transaction in the
             // response queue to reflect that if necessary. We are now sending
             // out a request while we haven't received all responses.
             nsAHttpTransaction *response = Response(0);
             if (response && !response->PipelinePosition())
                 response->SetPipelinePosition(1);
-            rv = trans->ReadSegments(this, (uint32_t)std::min(avail, (uint64_t)UINT32_MAX), &n);
-            if (NS_FAILED(rv)) return rv;
+
+#if defined(ENABLE_SCTP)
+            // SCTP transactions must be written to socket separately.
+           if (mReader && mReader->IsSctpSocket()) {
+                rv = trans->ReadSegments(mReader, avail, &n);
+            } else
+#endif  
+            rv = trans->ReadSegments(this, avail, &n);
+
+            if (NS_FAILED(rv)) {
+                return rv;
+            }
 
             if (n == 0) {
                 LOG(("send pipe is full"));
                 break;
             }
 
             mSendingToProgress += n;
             if (!mSuppressSendEvents && transport) {
@@ -896,20 +979,33 @@ nsHttpPipeline::FillSendBuf()
 
             if (!mSuppressSendEvents && transport) {
                 // Simulate a WAITING_FOR event
                 trans->OnTransportStatus(transport,
                                          NS_NET_STATUS_WAITING_FOR,
                                          mSendingToProgress);
             }
 
+#if defined(ENABLE_SCTP)
+            mCurrentReadTransaction = nullptr;
+#endif
+
             // It would be good to re-enable data read handlers via ResumeRecv()
             // except the read handler code can be synchronously dispatched on
             // the stack.
         }
         else
             mRequestIsPartial = true;
     }
     return NS_OK;
 }
 
+#if defined(ENABLE_SCTP)
+bool
+nsHttpPipeline::IsSctpSocket()
+{
+    // IsSctpSocket is meant to query connections, not pipelines.
+    return false;
+}
+#endif
+
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/nsHttpPipeline.h b/netwerk/protocol/http/nsHttpPipeline.h
--- a/netwerk/protocol/http/nsHttpPipeline.h
+++ b/netwerk/protocol/http/nsHttpPipeline.h
@@ -76,16 +76,23 @@ private:
 
     // indicates whether or not a true pipeline (more than 1 request without
     // a synchronous response) has been formed.
     bool mUtilizedPipeline;
 
     // used when calling ReadSegments/WriteSegments on a transaction.
     nsAHttpSegmentReader *mReader;
 
+#if defined(ENABLE_SCTP)
+    // transaction to pass to Connection's OnReadSegment
+    nsAHttpTransaction *mCurrentReadTransaction;
+    nsresult OnReadSegment(const char *, uint32_t, uint32_t *, nsAHttpTransaction *) override;  
+    bool IsSctpSocket() override;
+    virtual nsresult WriteSegments(nsAHttpSegmentWriter *, uint32_t, uint32_t *, nsAHttpTransaction *trans) override;
+#endif
     // send buffer
     nsCOMPtr<nsIInputStream>  mSendBufIn;
     nsCOMPtr<nsIOutputStream> mSendBufOut;
 
     // the push back buffer.  not exceeding nsIOService::gDefaultSegmentSize bytes.
     char     *mPushBackBuf;
     uint32_t  mPushBackLen;
     uint32_t  mPushBackMax;
diff --git a/netwerk/protocol/http/nsHttpTransaction.cpp b/netwerk/protocol/http/nsHttpTransaction.cpp
--- a/netwerk/protocol/http/nsHttpTransaction.cpp
+++ b/netwerk/protocol/http/nsHttpTransaction.cpp
@@ -78,16 +78,19 @@ LogHeaders(const char *lineStart)
 }
 
 //-----------------------------------------------------------------------------
 // nsHttpTransaction <public>
 //-----------------------------------------------------------------------------
 
 nsHttpTransaction::nsHttpTransaction()
     : mLock("transaction lock")
+#if defined(ENABLE_SCTP)
+    , mSctpInputStreamIdChanged(false)
+#endif
     , mRequestSize(0)
     , mConnection(nullptr)
     , mRequestHead(nullptr)
     , mResponseHead(nullptr)
     , mReader(nullptr)
     , mWriter(nullptr)
     , mContentLength(-1)
     , mContentRead(0)
@@ -149,17 +152,16 @@ nsHttpTransaction::nsHttpTransaction()
 #endif
     mSelfAddr.raw.family = PR_AF_UNSPEC;
     mPeerAddr.raw.family = PR_AF_UNSPEC;
 }
 
 nsHttpTransaction::~nsHttpTransaction()
 {
     LOG(("Destroying nsHttpTransaction @%p\n", this));
-
     if (mPushedStream) {
         mPushedStream->OnPushFailed();
         mPushedStream = nullptr;
     }
 
     if (mTokenBucketCancel) {
         mTokenBucketCancel->Cancel(NS_ERROR_ABORT);
         mTokenBucketCancel = nullptr;
@@ -658,17 +660,22 @@ NS_METHOD
 nsHttpTransaction::ReadRequestSegment(nsIInputStream *stream,
                                       void *closure,
                                       const char *buf,
                                       uint32_t offset,
                                       uint32_t count,
                                       uint32_t *countRead)
 {
     nsHttpTransaction *trans = (nsHttpTransaction *) closure;
+// No need to check for SCTP socket here.  TCP sockets can use trans version.
+#if defined(ENABLE_SCTP)
+    nsresult rv = trans->mReader->OnReadSegment(buf, count, countRead, trans);
+#else
     nsresult rv = trans->mReader->OnReadSegment(buf, count, countRead);
+#endif   
     if (NS_FAILED(rv)) return rv;
 
     if (trans->TimingEnabled()) {
         // Set the timestamp to Now(), only if it null
         trans->SetRequestStart(TimeStamp::Now(), true);
     }
 
     trans->CountSentBytes(*countRead);
@@ -676,32 +683,29 @@ nsHttpTransaction::ReadRequestSegment(ns
     return NS_OK;
 }
 
 nsresult
 nsHttpTransaction::ReadSegments(nsAHttpSegmentReader *reader,
                                 uint32_t count, uint32_t *countRead)
 {
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
-
     if (mTransactionDone) {
         *countRead = 0;
         return mStatus;
     }
-
     if (!mConnected) {
         mConnected = true;
         mConnection->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
     }
 
     mDeferredSendProgress = false;
     mReader = reader;
     nsresult rv = mRequestStream->ReadSegments(ReadRequestSegment, this, count, countRead);
     mReader = nullptr;
-
     if (mDeferredSendProgress && mConnection && mConnection->Transport()) {
         // to avoid using mRequestStream concurrently, OnTransportStatus()
         // did not report upload status off the ReadSegments() stack from nsSocketTransport
         // do it now.
         OnTransportStatus(mConnection->Transport(), NS_NET_STATUS_SENDING_TO, 0);
     }
     mDeferredSendProgress = false;
 
@@ -740,18 +744,24 @@ nsHttpTransaction::WritePipeSegment(nsIO
                                     void *closure,
                                     char *buf,
                                     uint32_t offset,
                                     uint32_t count,
                                     uint32_t *countWritten)
 {
     nsHttpTransaction *trans = (nsHttpTransaction *) closure;
 
-    if (trans->mTransactionDone)
+    if (trans->mTransactionDone) {
         return NS_BASE_STREAM_CLOSED; // stop iterating
+    }
+
+#if defined(ENABLE_SCTP)
+    if(trans->mSctpInputStreamIdChanged)
+        return NS_SCTP_WRONG_TRANSACTION;
+#endif
 
     if (trans->TimingEnabled()) {
         // Set the timestamp to Now(), only if it null
         trans->SetResponseStart(TimeStamp::Now(), true);
     }
 
     // Bug 1153929 - add checks to fix windows crash
     MOZ_ASSERT(trans->mWriter);
@@ -759,17 +769,28 @@ nsHttpTransaction::WritePipeSegment(nsIO
         return NS_ERROR_UNEXPECTED;
     }
 
     nsresult rv;
     //
     // OK, now let the caller fill this segment with data.
     //
     rv = trans->mWriter->OnWriteSegment(buf, count, countWritten);
-    if (NS_FAILED(rv)) return rv; // caller didn't want to write anything
+ 	
+#if defined(ENABLE_SCTP)
+    if (NS_FAILED(rv) && rv != NS_SCTP_INPUT_STREAM_ID_CHANGED) {
+        return rv; // caller didn't want to write anything
+    }
+    if (rv == NS_SCTP_INPUT_STREAM_ID_CHANGED)
+        trans->mSctpInputStreamIdChanged = true;
+#else
+    if (NS_FAILED(rv)) {
+        return rv; // caller didn't want to write anything
+    }
+#endif
 
     MOZ_ASSERT(*countWritten > 0, "bad writer");
     trans->CountRecvBytes(*countWritten);
     trans->mReceivedData = true;
     trans->mTransferSize += *countWritten;
 
     // Let the transaction "play" with the buffer.  It is free to modify
     // the contents of the buffer and/or modify countWritten.
@@ -786,25 +807,30 @@ nsHttpTransaction::WritePipeSegment(nsIO
 
 nsresult
 nsHttpTransaction::WriteSegments(nsAHttpSegmentWriter *writer,
                                  uint32_t count, uint32_t *countWritten)
 {
     static bool reentrantFlag = false;
     LOG(("nsHttpTransaction::WriteSegments %p reentrantFlag=%d",
          this, reentrantFlag));
+
     MOZ_DIAGNOSTIC_ASSERT(!reentrantFlag);
     reentrantFlag = true;
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
 
     if (mTransactionDone) {
         reentrantFlag = false;
         return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
     }
 
+#if defined(ENABLE_SCTP)
+    mSctpInputStreamIdChanged = false;
+#endif
+
     mWriter = writer;
 
 #ifdef WIN32 // bug 1153929
     MOZ_DIAGNOSTIC_ASSERT(mPipeOut);
     uint32_t * vtable = (uint32_t *) mPipeOut.get();
     MOZ_DIAGNOSTIC_ASSERT(*vtable != 0);
 #endif // WIN32
 
@@ -839,16 +865,27 @@ nsHttpTransaction::WriteSegments(nsAHttp
             rv = NS_ERROR_UNEXPECTED;
         }
     }
 
     reentrantFlag = false;
     return rv;
 }
 
+#if defined(ENABLE_SCTP)
+nsresult
+nsHttpTransaction::WriteSegments(nsAHttpSegmentWriter *writer,
+                                 uint32_t count,
+                                 uint32_t *countWritten,
+                                 nsAHttpTransaction *trans)
+{
+    return WriteSegments(writer, count, countWritten);
+}
+#endif
+
 nsresult
 nsHttpTransaction::SaveNetworkStats(bool enforce)
 {
 #ifdef MOZ_WIDGET_GONK
     // Check if active network and appid are valid.
     if (!mActiveNetworkInfo || mAppId == NECKO_NO_APP_ID) {
         return NS_OK;
     }
@@ -882,17 +919,16 @@ nsHttpTransaction::SaveNetworkStats(bool
     return NS_ERROR_NOT_IMPLEMENTED;
 #endif
 }
 
 void
 nsHttpTransaction::Close(nsresult reason)
 {
     LOG(("nsHttpTransaction::Close [this=%p reason=%x]\n", this, reason));
-
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     if (reason == NS_BINDING_RETARGETED) {
         LOG(("  close %p skipped due to ERETARGETED\n", this));
         return;
     }
 
     if (mClosed) {
         LOG(("  already closed\n"));
@@ -1059,17 +1095,16 @@ nsHttpTransaction::Close(nsresult reason
                 reason = NS_ERROR_NET_RESET;
             }
         }
 
         // honor the sticky connection flag...
         if (mCaps & NS_HTTP_STICKY_CONNECTION)
             relConn = false;
     }
-
     // mTimings.responseEnd is normally recorded based on the end of a
     // HTTP delimiter such as chunked-encodings or content-length. However,
     // EOF or an error still require an end time be recorded.
     if (TimingEnabled()) {
         const TimingStruct timings = Timings();
         if (timings.responseEnd.IsNull() && !timings.responseStart.IsNull()) {
             SetResponseEnd(TimeStamp::Now());
         }
@@ -1664,17 +1699,16 @@ nsresult
 nsHttpTransaction::HandleContent(char *buf,
                                  uint32_t count,
                                  uint32_t *contentRead,
                                  uint32_t *contentRemaining)
 {
     nsresult rv;
 
     LOG(("nsHttpTransaction::HandleContent [this=%p count=%u]\n", this, count));
-
     *contentRead = 0;
     *contentRemaining = 0;
 
     MOZ_ASSERT(mConnection);
 
     if (!mDidContentStart) {
         rv = HandleContentStart();
         if (NS_FAILED(rv)) return rv;
@@ -1733,26 +1767,24 @@ nsHttpTransaction::HandleContent(char *b
 
     if (*contentRead) {
         // update count of content bytes read and report progress...
         mContentRead += *contentRead;
     }
 
     LOG(("nsHttpTransaction::HandleContent [this=%p count=%u read=%u mContentRead=%lld mContentLength=%lld]\n",
         this, count, *contentRead, mContentRead, mContentLength));
-
     // Check the size of chunked responses. If we exceed the max pipeline size
     // for this response reschedule the pipeline
     if ((mClassification != CLASS_SOLO) &&
         mChunkedDecoder &&
         ((mContentRead + mChunkedDecoder->GetChunkRemaining()) >
          mMaxPipelineObjectSize)) {
         CancelPipeline(nsHttpConnectionMgr::BadUnexpectedLarge);
     }
-
     // check for end-of-file
     if ((mContentRead == mContentLength) ||
         (mChunkedDecoder && mChunkedDecoder->ReachedEOF())) {
         // the transaction is done with a complete response.
         mTransactionDone = true;
         mResponseIsComplete = true;
         ReleaseBlockingTransaction();
 
@@ -1775,23 +1807,21 @@ nsHttpTransaction::HandleContent(char *b
 }
 
 nsresult
 nsHttpTransaction::ProcessData(char *buf, uint32_t count, uint32_t *countRead)
 {
     nsresult rv;
 
     LOG(("nsHttpTransaction::ProcessData [this=%p count=%u]\n", this, count));
-
     *countRead = 0;
 
     // we may not have read all of the headers yet...
     if (!mHaveAllHeaders) {
         uint32_t bytesConsumed = 0;
-
         do {
             uint32_t localBytesConsumed = 0;
             char *localBuf = buf + bytesConsumed;
             uint32_t localCount = count - bytesConsumed;
 
             rv = ParseHead(localBuf, localCount, &localBytesConsumed);
             if (NS_FAILED(rv) && rv != NS_ERROR_NET_INTERRUPT)
                 return rv;
diff --git a/netwerk/protocol/http/nsHttpTransaction.h b/netwerk/protocol/http/nsHttpTransaction.h
--- a/netwerk/protocol/http/nsHttpTransaction.h
+++ b/netwerk/protocol/http/nsHttpTransaction.h
@@ -223,16 +223,24 @@ private:
     nsCOMPtr<nsISupports>           mSecurityInfo;
     nsCOMPtr<nsIAsyncInputStream>   mPipeIn;
     nsCOMPtr<nsIAsyncOutputStream>  mPipeOut;
     nsCOMPtr<nsISchedulingContext>  mSchedulingContext;
 
     nsCOMPtr<nsISupports>             mChannel;
     nsCOMPtr<nsIHttpActivityObserver> mActivityDistributor;
 
+#if defined(ENABLE_SCTP)
+    // Used in nsHttpTransaction::WritePipeSegment to break loop in
+    // nsPipeOutputStream::WriteSegments
+    bool   mSctpInputStreamIdChanged;
+    virtual nsresult WriteSegments(nsAHttpSegmentWriter *, uint32_t, uint32_t *, nsAHttpTransaction *trans) override;
+  //  nsresult WriteSegments(nsAHttpSegmentWriter *, uint32_t, uint32_t *, nsAHttpTransaction *) override;	
+#endif
+
     nsCString                       mReqHeaderBuf;    // flattened request headers
     nsCOMPtr<nsIInputStream>        mRequestStream;
     int64_t                         mRequestSize;
 
     RefPtr<nsAHttpConnection>     mConnection;
     RefPtr<nsHttpConnectionInfo>  mConnInfo;
     nsHttpRequestHead              *mRequestHead;     // weak ref
     nsHttpResponseHead             *mResponseHead;    // owning pointer
diff --git a/nsprpub/config/autoconf.mk.in b/nsprpub/config/autoconf.mk.in
--- a/nsprpub/config/autoconf.mk.in
+++ b/nsprpub/config/autoconf.mk.in
@@ -115,16 +115,19 @@ PR_MD_ASFILES	= @PR_MD_ASFILES@
 PR_MD_ARCH_DIR	= @PR_MD_ARCH_DIR@
 CPU_ARCH	= @CPU_ARCH@
 
 OS_TARGET	= @OS_TARGET@
 OS_ARCH		= @OS_ARCH@
 OS_RELEASE	= @OS_RELEASE@
 OS_TEST		= @OS_TEST@
 
+ENABLE_SCTP     = @ENABLE_SCTP@
+USE_LIBSCTP     = @USE_LIBSCTP@
+
 NOSUCHFILE	= @NOSUCHFILE@
 AIX_LINK_OPTS	= @AIX_LINK_OPTS@
 MOZ_OBJFORMAT	= @MOZ_OBJFORMAT@
 ULTRASPARC_LIBRARY = @ULTRASPARC_LIBRARY@
 
 OBJECT_MODE	= @OBJECT_MODE@
 ifdef OBJECT_MODE
 export OBJECT_MODE
diff --git a/nsprpub/configure b/nsprpub/configure
--- a/nsprpub/configure
+++ b/nsprpub/configure
@@ -648,16 +648,18 @@ PROFILE_USE_LDFLAGS
 PROFILE_USE_CFLAGS
 PROFILE_GEN_LDFLAGS
 PROFILE_GEN_CFLAGS
 IMPLIB
 FILTER
 ASFLAGS
 AR_FLAGS
 DEFINES
+USE_LIBSCTP
+ENABLE_SCTP
 MACOSX_DEPLOYMENT_TARGET
 OS_TEST
 OS_RELEASE
 OS_ARCH
 OS_TARGET
 DSO_LDOPTS
 DSO_CFLAGS
 MKSHLIB
@@ -815,16 +817,17 @@ with_soft_float
 with_symbian_sdk
 with_ccache
 enable_strip
 with_pthreads
 enable_user_pthreads
 enable_nspr_threads
 with_bthreads
 enable_ipv6
+enable_sctp
 enable_wrap_malloc
 with_wrap_malloc
 '
       ac_precious_vars='build_alias
 host_alias
 target_alias
 CC
 CFLAGS
@@ -1466,16 +1469,17 @@ Optional Features:
                           Set the minimum MacOS version needed at runtime
                           10.2 for ppc, 10.4 for x86
   --disable-os2-high-mem  Disable high-memory support on OS/2
 
   --enable-strip          Enable stripping of shared libs and programs
   --enable-user-pthreads  Build using userland pthreads
   --enable-nspr-threads   Build using classic nspr threads
   --enable-ipv6           Compile ipv6 support
+  --enable-sctp           Build with SCTP support enabled
   --enable-wrap-malloc    Wrap malloc calls (gnu linker only)
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-android-ndk=DIR
                           location where the Android NDK can be found
   --with-android-toolchain=DIR
@@ -2495,16 +2499,19 @@ NSPR_MODNAME=nspr20
 USE_PTHREADS=
 USE_USER_PTHREADS=
 USE_NSPR_THREADS=
 USE_N32=
 USE_X32=
 USE_64=
 USE_CPLUS=
 USE_IPV6=
+USE_LIBSCTP=
+_HAVE_SCTP=
+ENABLE_SCTP=
 USE_MDUPDATE=
 _MACOSX_DEPLOYMENT_TARGET=
 _OPTIMIZE_FLAGS=-O
 _DEBUG_FLAGS=-g
 MOZ_DEBUG=1
 MOZ_OPTIMIZE=
 OBJDIR='$(OBJDIR_NAME)'
 OBJDIR_NAME=.
@@ -8519,16 +8526,185 @@ case "$target" in
         $as_echo "#define _PR_HAVE_GETHOST_R_POINTER 1" >>confdefs.h
 
     fi
     ;;
 esac
 
 OS_LIBS="$_PTHREAD_LDFLAGS $OS_LIBS"
 
+
+
+
+# Check whether --enable-sctp was given.
+if test "${enable_sctp+set}" = set; then :
+  enableval=$enable_sctp;  if test "$enableval" = "yes"; then
+          for ac_header in sys/types.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/types.h" "ac_cv_header_sys_types_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_types_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_TYPES_H 1
+_ACEOF
+
+fi
+
+done
+
+          for ac_header in sys/socket.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/socket.h" "ac_cv_header_sys_socket_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_socket_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_SOCKET_H 1
+_ACEOF
+
+fi
+
+done
+
+          for ac_header in netinet/in.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "netinet/in.h" "ac_cv_header_netinet_in_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_in_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NETINET_IN_H 1
+_ACEOF
+
+fi
+
+done
+
+          for ac_header in netinet/sctp.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "netinet/sctp.h" "ac_cv_header_netinet_sctp_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_sctp_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NETINET_SCTP_H 1
+_ACEOF
+
+fi
+
+done
+
+          for ac_header in netinet/sctp_uio.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "netinet/sctp_uio.h" "ac_cv_header_netinet_sctp_uio_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_sctp_uio_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NETINET_SCTP_UIO_H 1
+_ACEOF
+
+fi
+
+done
+
+
+                    LDOPTS_SAVE=$LDOPTS
+          CFLAGS_SAVE=$CFLAGS
+
+                    case "$target" in
+          *-linux*)
+              USE_LIBSCTP=1
+              ;;
+          *-darwin*)
+              USE_LIBSCTP=1
+              ;;
+          *-freebsd*)
+              OS_RELEASE_MAJOR=`uname -r | sed 's/\..*//'`
+              if test "$OS_RELEASE_MAJOR" -lt 7 ; then
+                                    as_fn_error $? " --enable-sctp option not supported for FreeBSD prior to version 7.0" "$LINENO" 5;
+              fi
+              SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS=
+              if test `uname -r | sed 's/-.*//'` = "7.2" ; then
+                  $as_echo "#define SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS 1" >>confdefs.h
+
+              fi
+              ;;
+          *)
+                            as_fn_error $? " --enable-sctp option not supported for this target system" "$LINENO" 5;
+              ;;
+          esac
+
+                    if test -n "$USE_LIBSCTP"; then
+              LDOPTS="$LDOPTS -lsctp"
+          fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether SCTP is supported" >&5
+$as_echo_n "checking whether SCTP is supported... " >&6; }
+if ${nspr_cv_sctp+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+  if test "$cross_compiling" = yes; then :
+  nspr_cv_sctp=no
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_SCTP_H
+#include <netinet/sctp.h>
+#endif
+#ifdef HAVE_NETINET_SCTP_UIO_H
+#include <netinet/sctp_uio.h>
+#endif
+#include <stdlib.h>
+int main(void) {
+    int s, opt = 1;
+    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0)
+       exit(1);
+    if (setsockopt(s, IPPROTO_SCTP, SCTP_NODELAY, &opt, sizeof(int)) < 0)
+       exit(2);
+    exit(0);
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  nspr_cv_sctp=yes
+else
+  nspr_cv_sctp=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $nspr_cv_sctp" >&5
+$as_echo "$nspr_cv_sctp" >&6; }
+
+if test "$nspr_cv_sctp" = "yes"; then
+    _HAVE_SCTP=1
+fi
+
+
+          if test -n "$_HAVE_SCTP"; then
+              ENABLE_SCTP=1
+              $as_echo "#define ENABLE_SCTP 1" >>confdefs.h
+
+              if test -n "$USE_LIBSCTP"; then
+                  DSO_LDOPTS="$DSO_LDOPTS -lsctp"
+              fi
+          else
+              LDOPTS=$LDOPTS_SAVE
+              CFLAGS=$CFLAGS_SAVE
+              as_fn_error $? " --enable-sctp: system does not support SCTP " "$LINENO" 5;
+          fi
+      fi
+fi
+
+
+
 if test -n "$_SAVE_OPTIMIZE_FLAGS"; then
     _OPTIMIZE_FLAGS="$_SAVE_OPTIMIZE_FLAGS"
 fi
 
 if test -n "$_SAVE_DEBUG_FLAGS"; then
     _DEBUG_FLAGS="$_SAVE_DEBUG_FLAGS"
 fi
 
@@ -8688,16 +8864,19 @@ fi
 
 
 
 
 
 
 
 
+
+
+
 MAKEFILES="
     Makefile
     config/Makefile
     config/autoconf.mk
     config/nsprincl.mk
     config/nsprincl.sh
     config/nspr-config
     config/nspr.pc
diff --git a/nsprpub/configure.in b/nsprpub/configure.in
--- a/nsprpub/configure.in
+++ b/nsprpub/configure.in
@@ -22,16 +22,19 @@ NSPR_MODNAME=nspr20
 USE_PTHREADS=
 USE_USER_PTHREADS=
 USE_NSPR_THREADS=
 USE_N32=
 USE_X32=
 USE_64=
 USE_CPLUS=
 USE_IPV6=
+USE_LIBSCTP=
+_HAVE_SCTP=
+ENABLE_SCTP=
 USE_MDUPDATE=
 _MACOSX_DEPLOYMENT_TARGET=
 _OPTIMIZE_FLAGS=-O
 _DEBUG_FLAGS=-g
 MOZ_DEBUG=1
 MOZ_OPTIMIZE=
 OBJDIR='$(OBJDIR_NAME)'
 OBJDIR_NAME=.
@@ -2920,16 +2923,120 @@ case "$target" in
         AC_DEFINE(_PR_HAVE_GETHOST_R)
         AC_DEFINE(_PR_HAVE_GETHOST_R_POINTER)
     fi
     ;;
 esac
 
 OS_LIBS="$_PTHREAD_LDFLAGS $OS_LIBS"
 
+dnl Support for SCTP
+dnl ========================================================
+dnl = --enable-sctp
+dnl = enable use of the sctp transport protocol
+dnl ========================================================
+dnl
+dnl NSPR_CHECK_SCTP
+dnl
+dnl check for presence of SCTP protocol support
+dnl
+
+AC_DEFUN([NSPR_CHECK_SCTP],
+[
+  AC_CACHE_CHECK([whether SCTP is supported], [nspr_cv_sctp], [
+  AC_TRY_RUN([
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_SCTP_H
+#include <netinet/sctp.h>
+#endif
+#ifdef HAVE_NETINET_SCTP_UIO_H
+#include <netinet/sctp_uio.h>
+#endif
+#include <stdlib.h>
+int main(void) {
+    int s, opt = 1;
+    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0)
+       exit(1);
+    if (setsockopt(s, IPPROTO_SCTP, SCTP_NODELAY, &opt, sizeof(int)) < 0)
+       exit(2);
+    exit(0);
+}], [nspr_cv_sctp=yes], [nspr_cv_sctp=no], [nspr_cv_sctp=no])])
+
+if test "$nspr_cv_sctp" = "yes"; then
+    _HAVE_SCTP=1
+fi
+])
+
+AC_ARG_ENABLE(sctp,
+    [  --enable-sctp           Build with SCTP support enabled],
+    [ if test "$enableval" = "yes"; then
+dnl          AC_CHECK_HEADERS([sys/types.h, sys/socket.h, netinet/in.h, netinet/sctp.h, netinet/sctp_uio.h])
+          AC_CHECK_HEADERS(sys/types.h)
+          AC_CHECK_HEADERS(sys/socket.h)
+          AC_CHECK_HEADERS(netinet/in.h)
+          AC_CHECK_HEADERS(netinet/sctp.h)
+          AC_CHECK_HEADERS(netinet/sctp_uio.h)
+
+          dnl - need to set LDOPTS or CFLAGS for NSPR_CHECK_SCTP, so save current value.
+          LDOPTS_SAVE=$LDOPTS
+          CFLAGS_SAVE=$CFLAGS
+
+          dnl - do OS based checks and configuration.
+          case "$target" in
+          *-linux*)
+              USE_LIBSCTP=1
+              ;;
+          *-darwin*)
+              USE_LIBSCTP=1
+              ;;
+          *-freebsd*)
+              OS_RELEASE_MAJOR=`uname -r | sed 's/\..*//'`
+              if test "$OS_RELEASE_MAJOR" -lt 7 ; then
+                  dnl - unsupported version
+                  AC_MSG_ERROR([ --enable-sctp option not supported for FreeBSD prior to version 7.0]);
+              fi
+              SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS=
+              if test `uname -r | sed 's/-.*//'` = "7.2" ; then
+                  AC_DEFINE(SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS)
+              fi
+              ;;
+          *)
+              dnl - unknown system
+              AC_MSG_ERROR([ --enable-sctp option not supported for this target system]);
+              ;;
+          esac
+
+          dnl - check for SCTP support
+          if test -n "$USE_LIBSCTP"; then
+              LDOPTS="$LDOPTS -lsctp"
+          fi
+          NSPR_CHECK_SCTP
+
+          if test -n "$_HAVE_SCTP"; then
+              ENABLE_SCTP=1
+              AC_DEFINE(ENABLE_SCTP)
+              if test -n "$USE_LIBSCTP"; then
+                  DSO_LDOPTS="$DSO_LDOPTS -lsctp"
+              fi
+          else
+              LDOPTS=$LDOPTS_SAVE
+              CFLAGS=$CFLAGS_SAVE
+              AC_MSG_ERROR([ --enable-sctp: system does not support SCTP ]);
+          fi
+      fi])
+
+
 dnl If the user passed in arg to --enable-optimize or --enable-debug,
 dnl make sure that we use it.
 if test -n "$_SAVE_OPTIMIZE_FLAGS"; then
     _OPTIMIZE_FLAGS="$_SAVE_OPTIMIZE_FLAGS"
 fi
 
 if test -n "$_SAVE_DEBUG_FLAGS"; then
     _DEBUG_FLAGS="$_SAVE_DEBUG_FLAGS"
@@ -3055,16 +3162,19 @@ AC_SUBST(DSO_CFLAGS)
 AC_SUBST(DSO_LDOPTS)
 
 AC_SUBST(OS_TARGET)
 AC_SUBST(OS_ARCH)
 AC_SUBST(OS_RELEASE)
 AC_SUBST(OS_TEST)
 AC_SUBST(MACOSX_DEPLOYMENT_TARGET)
 
+AC_SUBST(ENABLE_SCTP)
+AC_SUBST(USE_LIBSCTP)
+
 AC_SUBST(DEFINES)
 AC_SUBST(DEFS)
 AC_SUBST(AR)
 AC_SUBST(AR_FLAGS)
 AC_SUBST(AS)
 AC_SUBST(ASFLAGS)
 AC_SUBST(LD)
 AC_SUBST(RANLIB)
diff --git a/nsprpub/pr/include/md/_darwin.h b/nsprpub/pr/include/md/_darwin.h
--- a/nsprpub/pr/include/md/_darwin.h
+++ b/nsprpub/pr/include/md/_darwin.h
@@ -137,17 +137,29 @@ static inline PRInt32 _MD_ATOMIC_SET(PRI
     } while (!OSAtomicCompareAndSwap32(oldval, newval, val));
     return oldval;
 }
 #define _MD_ATOMIC_ADD(ptr, val)    OSAtomicAdd32(val, ptr)
 #endif /* __arm__ || __aarch64__ */
 
 #define USE_SETJMP
 
-#if !defined(_PR_PTHREADS)
+#if defined(_PR_PTHREADS)
+#if defined(ENABLE_SCTP)
+extern PRInt32 _MD_Sctp_Recvmsg(int osfd, void *buf, PRInt32 amount,
+                                PRNetAddr *from, PRUint32 *fromlen,
+                                PRSctp_SndRcvInfo *sinfo, PRInt32 *msg_flags);
+#define _MD_SCTP_RECVMSG            _MD_Sctp_Recvmsg
+extern PRInt32 _MD_SCTPGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data);
+#define _MD_SCTPGETSOCKETOPTION     _MD_SCTPGetSocketOption
+extern PRInt32 _MD_SCTPSetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data);
+#define _MD_SCTPSETSOCKETOPTION     _MD_SCTPSetSocketOption
+#endif /* ENABLE_SCTP */
+
+#else /* ! _PR_PTHREADS */
 
 #include <setjmp.h>
 
 #define PR_CONTEXT_TYPE	jmp_buf
 
 #define CONTEXT(_th)       ((_th)->md.context)
 #define _MD_GET_SP(_th)    (((struct sigcontext *) (_th)->md.context)->sc_onstack)
 #define PR_NUM_GCREGS	    _JBLEN
diff --git a/nsprpub/pr/include/md/_freebsd.h b/nsprpub/pr/include/md/_freebsd.h
--- a/nsprpub/pr/include/md/_freebsd.h
+++ b/nsprpub/pr/include/md/_freebsd.h
@@ -59,23 +59,38 @@
 #if defined(_PR_PTHREADS)
 #if __FreeBSD_version >= 400008
 /*
  * libc_r before this version of FreeBSD doesn't have poll().
  * Although libc has poll(), it is not thread-safe so we can't
  * use it in the pthreads version.
  */
 #define _PR_POLL_AVAILABLE
-#endif
-#else
+#endif /*FreeBsd >=4*/
+
+#if defined(ENABLE_SCTP)
+extern PRInt32 _MD_Sctp_Recvmsg(int osfd, void *buf, PRInt32 amount,
+                                PRNetAddr *from, PRUint32 *fromlen,
+                                PRSctp_SndRcvInfo *sinfo,
+                                PRInt32 *msg_flags);
+#define _MD_SCTP_RECVMSG            _MD_Sctp_Recvmsg
+extern PRInt32 _MD_SCTPGetSocketOption(PRFileDesc *fd,
+                                       PRSocketOptionData *data);
+#define _MD_SCTPGETSOCKETOPTION     _MD_SCTPGetSocketOption
+extern PRInt32 _MD_SCTPSetSocketOption(PRFileDesc *fd,
+                                       const PRSocketOptionData *data);
+#define _MD_SCTPSETSOCKETOPTION     _MD_SCTPSetSocketOption
+#endif /* ENABLE_SCTP */
+
+#else /* !PR_PTHREADS */
 #if __FreeBSD_version >= 300000
 #define _PR_POLL_AVAILABLE
 #define _PR_USE_POLL
-#endif
-#endif
+#endif /*FreeBsd >=3*/
+#endif /* !PR_PTHREADS */
 
 #define _PR_HAVE_SYSV_SEMAPHORES
 #define PR_HAVE_SYSV_NAMED_SHARED_MEMORY
 
 #if __FreeBSD_version >= 400014
 #define _PR_INET6
 #define _PR_HAVE_INET_NTOP
 #define _PR_HAVE_GETHOSTBYNAME2
diff --git a/nsprpub/pr/include/md/_linux.h b/nsprpub/pr/include/md/_linux.h
--- a/nsprpub/pr/include/md/_linux.h
+++ b/nsprpub/pr/include/md/_linux.h
@@ -316,16 +316,27 @@ static inline PRInt32 _MD_ATOMIC_SET(PRI
 #define _PR_HAVE_GETHOST_R_INT
 #endif
 
 #ifdef _PR_PTHREADS
 
 extern void _MD_CleanupBeforeExit(void);
 #define _MD_CLEANUP_BEFORE_EXIT _MD_CleanupBeforeExit
 
+#if defined(ENABLE_SCTP)
+extern int32_t _MD_Sctp_Recvmsg(int osfd, void *buf, int32_t amount,
+                                PRNetAddr *from, uint32_t *fromlen,
+                                PRSctp_SndRcvInfo *sinfo, int32_t *msg_flags);
+#define        _MD_SCTP_RECVMSG        _MD_Sctp_Recvmsg
+extern int32_t _MD_SCTPGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data);
+#define _MD_SCTPGETSOCKETOPTION     _MD_SCTPGetSocketOption
+extern int32 _MD_SCTPSetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data);
+#define _MD_SCTPSETSOCKETOPTION     _MD_SCTPSetSocketOption
+#endif /* ENABLE_SCTP */
+
 #else  /* ! _PR_PTHREADS */
 
 #include <setjmp.h>
 
 #define PR_CONTEXT_TYPE	sigjmp_buf
 
 #define CONTEXT(_th) ((_th)->md.context)
 
diff --git a/nsprpub/pr/include/prio.h b/nsprpub/pr/include/prio.h
--- a/nsprpub/pr/include/prio.h
+++ b/nsprpub/pr/include/prio.h
@@ -176,16 +176,21 @@ union PRNetAddr {
                                         /* bind fails if size is not 108. */
 #else
         char path[104];                 /* null-terminated pathname */
 #endif
     } local;
 #endif
 };
 
+#if defined(ENABLE_SCTP)
+/* PRNetAddr must be defined before including SCTP data structures. */
+#include "prsctp.h"
+#endif
+
 /*
 ***************************************************************************
 ** PRSockOption
 **
 ** The file descriptors can have predefined options set after they file
 ** descriptor is created to change their behavior. Only the options in
 ** the following enumeration are supported.
 ***************************************************************************
@@ -208,16 +213,29 @@ typedef enum PRSockOption
     PR_SockOpt_McastTimeToLive, /* multicast timetolive */
     PR_SockOpt_McastLoopback,   /* multicast loopback */
 
     PR_SockOpt_NoDelay,         /* don't delay send to coalesce packets */
     PR_SockOpt_MaxSegment,      /* maximum segment size */
     PR_SockOpt_Broadcast,       /* enable broadcast */
     PR_SockOpt_Reuseport,       /* allow local address & port reuse on
                                  * platforms that support it */
+#if defined(ENABLE_SCTP)
+   /* Adding socket options to support SCTP */
+    PR_SockOpt_DefaultSendParam,   /* set default outgoing parameter values */
+    PR_SockOpt_UseExtRcvInfo,      /* enable/disable extrcvinfo notifications */
+    PR_SockOpt_Events,             /* enable/disable sndrcvinfo notifications */
+    PR_SockOpt_InitMsg,            /* get/set INIT chunk parameters */
+    PR_SockOpt_AssocInfo,          /* get/set/change association info */
+    PR_SockOpt_SctpNoDelay,        /* enable/disable Nagle algorithm */
+    PR_SockOpt_SctpMaxSegment,     /* get/set maximum fragment size */
+    PR_SockOpt_Status,             /* get current state of association */
+    PR_SockOpt_SetPeerPrimaryAddr, /* set primary address of peer */
+    PR_SockOpt_SetPrimaryAddr,     /* set primary address */
+#endif
     PR_SockOpt_Last
 } PRSockOption;
 
 typedef struct PRLinger {
 	PRBool polarity;		    /* Polarity of the option's setting */
 	PRIntervalTime linger;	    /* Time to linger before closing */
 } PRLinger;
 
@@ -244,16 +262,29 @@ typedef struct PRSocketOptionData
         PRBool broadcast;           /* Enable broadcast */
         PRSize max_segment;         /* Maximum segment size */
         PRSize recv_buffer_size;    /* Receive buffer size */
         PRSize send_buffer_size;    /* Send buffer size */
         PRLinger linger;            /* Time to linger on close if data present */
         PRMcastRequest add_member;  /* add an IP group membership */
         PRMcastRequest drop_member; /* Drop an IP group membership */
         PRNetAddr mcast_if;         /* multicast interface address */
+/* Adding union members to support SCTP socket options. */
+#if defined(ENABLE_SCTP)
+        PRSctp_SndRcvInfo sndrcvinfo;   /* set/get msg params/info */
+        PRBool useextrcvinfo;           /* enable/disable extrcvinfo messages */
+        PRSctp_Event_Subscribe events;  /* enable/disable sendrcvinfo messages */
+        PRSctp_InitMsg initmsg;         /* get/set INIT chunk parameters */
+        PRSctp_AssocParams assocparams; /* get/set/change association info */
+        PRBool sctp_nodelay;            /* enable/disable Nagle algorithm */
+        PRSctp_Assoc_Value sctp_maxseg; /* set/get max fragment size */
+        PRSctp_Status status;           /* get current state of association */
+        PRSctp_SetPeerPrim setpeerprim; /* set primary address of peer */
+        PRSctp_SetPrim setprim;         /* set primary address */
+#endif
     } value;
 } PRSocketOptionData;
 
 /*
 ***************************************************************************
 ** PRIOVec
 **
 ** The I/O vector is used by the write vector method to describe the areas
@@ -271,17 +302,18 @@ typedef struct PRIOVec {
 ***************************************************************************
 */
 typedef enum PRDescType
 {
     PR_DESC_FILE = 1,
     PR_DESC_SOCKET_TCP = 2,
     PR_DESC_SOCKET_UDP = 3,
     PR_DESC_LAYERED = 4,
-    PR_DESC_PIPE = 5
+    PR_DESC_PIPE = 5,
+    PR_DESC_SOCKET_SCTP_ONE_TO_ONE = 6
 } PRDescType;
 
 typedef enum PRSeekWhence {
     PR_SEEK_SET = 0,
     PR_SEEK_CUR = 1,
     PR_SEEK_END = 2
 } PRSeekWhence;
 
@@ -338,16 +370,25 @@ typedef PRInt32 (PR_CALLBACK *PRSendtoFN
 typedef PRInt16 (PR_CALLBACK *PRPollFN)(
     PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags);
 typedef PRInt32 (PR_CALLBACK *PRAcceptreadFN)(
     PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr,
     void *buf, PRInt32 amount, PRIntervalTime t);
 typedef PRInt32 (PR_CALLBACK *PRTransmitfileFN)(
      PRFileDesc *sd, PRFileDesc *fd, const void *headers,
      PRInt32 hlen, PRTransmitFileFlags flags, PRIntervalTime t);
+#if defined(ENABLE_SCTP)
+typedef PRInt32 (PR_CALLBACK *PRSctp_recvmsgFN)(
+    PRFileDesc *fd, void *msg, PRInt32 msgsz, PRNetAddr *from, PRUint32 *fromlen,
+    PRSctp_SndRcvInfo *sinfo, PRInt32 *msg_flags, PRIntervalTime timeout);
+typedef PRInt32 (PR_CALLBACK *PRSctp_sendmsgFN)(
+    PRFileDesc *fd, const void *msg, PRInt32 msgsz, const PRNetAddr *to, PRUint32 tolen,
+    PRInt32 ppid, PRUint32 flags, PRInt16 stream, PRInt32 timetolive, PRInt32 context,
+    PRIntervalTime timeout);
+#endif
 typedef PRStatus (PR_CALLBACK *PRGetsocknameFN)(PRFileDesc *fd, PRNetAddr *addr);
 typedef PRStatus (PR_CALLBACK *PRGetpeernameFN)(PRFileDesc *fd, PRNetAddr *addr);
 typedef PRStatus (PR_CALLBACK *PRGetsocketoptionFN)(
     PRFileDesc *fd, PRSocketOptionData *data);
 typedef PRStatus (PR_CALLBACK *PRSetsocketoptionFN)(
     PRFileDesc *fd, const PRSocketOptionData *data);
 typedef PRInt32 (PR_CALLBACK *PRSendfileFN)(
 	PRFileDesc *networkSocket, PRSendFileData *sendData,
@@ -378,18 +419,23 @@ struct PRIOMethods {
     PRSendFN send;                  /* Send all the bytes specified             */
     PRRecvfromFN recvfrom;          /* Solicit (net) bytes and report source    */
     PRSendtoFN sendto;              /* Send bytes to (net) address specified    */
     PRPollFN poll;                  /* Test the fd to see if it is ready        */
     PRAcceptreadFN acceptread;      /* Accept and read on a new (net) fd        */
     PRTransmitfileFN transmitfile;  /* Transmit at entire file                  */
     PRGetsocknameFN getsockname;    /* Get (net) address associated with fd     */
     PRGetpeernameFN getpeername;    /* Get peer's (net) address                 */
+#if defined(ENABLE_SCTP)
+    PRSctp_recvmsgFN sctp_recvmsg;  /* Receive the next message                 */
+    PRSctp_sendmsgFN sctp_sendmsg;  /* Send the specified bytes as a message    */
+#else
     PRReservedFN reserved_fn_6;     /* reserved for future use */
     PRReservedFN reserved_fn_5;     /* reserved for future use */
+#endif
     PRGetsocketoptionFN getsocketoption;
                                     /* Get current setting of specified option  */
     PRSetsocketoptionFN setsocketoption;
                                     /* Set value of specified option            */
     PRSendfileFN sendfile;			/* Send a (partial) file with header/trailer*/
     PRConnectcontinueFN connectcontinue;
                                     /* Continue a nonblocking connect */
     PRReservedFN reserved_fn_3;		/* reserved for future use */
@@ -1223,16 +1269,58 @@ NSPR_API(PRFileDesc*)    PR_OpenUDPSocke
  *     to the PRFileDesc created for the newly opened TCP socket.
  *     Returns a NULL pointer if the creation of a new TCP socket failed.
  *
  **************************************************************************
  */
 
 NSPR_API(PRFileDesc*)    PR_OpenTCPSocket(PRIntn af);
 
+#if defined(ENABLE_SCTP)
+/*
+ *************************************************************************
+ * FUNCTION: PR_OpenSCTPSocket
+ * DESCRIPTION:
+ *     Create a new SCTP socket of the specified address family and type.
+ * INPUTS:
+ *     PRIntn af
+ *     Address family
+ *     PRInt32 type
+ *     Socket type
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_NewSCTPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened SCTP socket. 	
+ *     Returns a NULL pointer if the creation of a new SCTP socket failed.
+ *
+ **************************************************************************
+ */
+NSPR_API(PRFileDesc*)    PR_OpenSCTPSocket(PRIntn af, PRInt32 type);
+/*
+ *************************************************************************
+ * FUNCTION: PR_OpenSCTPOneToOneSocket
+ * DESCRIPTION:
+ *     Create a new SCTP 1-to-1 style socket of the specified address family.
+ * INPUTS:
+ *     PRIntn af
+ *       Address family
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_NewSCTPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened SCTP 1-to-1 style socket.
+ *     Returns a NULL pointer if the creation of a new SCTP socket failed.
+ *
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*)    PR_OpenSCTPOneToOneSocket(PRIntn af);
+#endif
+
 /*
  *************************************************************************
  * FUNCTION: PR_Connect
  * DESCRIPTION:
  *     Initiate a connection on a socket.
  * INPUTS:
  *     PRFileDesc *fd
  *       Points to a PRFileDesc object representing a socket
@@ -1449,16 +1537,57 @@ NSPR_API(PRStatus)    PR_Shutdown(PRFile
  **************************************************************************
  */
 
 #define PR_MSG_PEEK 0x2
 
 NSPR_API(PRInt32)    PR_Recv(PRFileDesc *fd, void *buf, PRInt32 amount,
                 PRIntn flags, PRIntervalTime timeout);
 
+#if defined(ENABLE_SCTP)
+ /*
+  *************************************************************************
+ * FUNCTION: PR_SctpRecvmsg
+ * DESCRIPTION:
+ *    Receive a specified number of bytes from a connected socket.
+ *     The operation will block until some positive number of bytes are
+ *     transferred, a time out has occurred, or there is an error.
+ *     No more than 'amount' bytes will be transferred.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing a socket.
+ *     void *buf
+ *       pointer to a buffer to hold the data received.
+ *     PRInt32 msgsz
+ *       the size of 'buf' (in bytes)
+ *     PRNetAddr *from
+ *       points to sender's address
+ *     PRUint32 *fromlen
+ *       pointer to length of sender's address structure
+ *     PRSctp_SndRcvInfo *sinfo
+ *       points to send_receive info structure
+ *     PRInt32 *msgflags
+ *       points to message flags
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *         a positive number indicates the number of bytes actually received.
+ *         0 means the network connection is closed.
+ *         -1 indicates a failure. The reason for the failure is obtained
+ *         by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32)    PR_SctpRecvmsg(PRFileDesc *fd, void *buf,
+                PRInt32 msgsz, PRNetAddr *from, PRUint32 *fromlen,
+                PRSctp_SndRcvInfo *sinfo, PRInt32 *msgflags,
+                PRIntervalTime timeout);
+
+#endif
+
 /*
  *************************************************************************
  * FUNCTION: PR_Send
  * DESCRIPTION:
  *    Send a specified number of bytes from a connected socket.
  *     The operation will block until all bytes are 
  *     processed, a time out has occurred, or there is an error. 
  * INPUTS:
@@ -1480,16 +1609,62 @@ NSPR_API(PRInt32)    PR_Recv(PRFileDesc 
  *     operation failed. The reason for the failure is obtained by calling
  *     PR_GetError().
  **************************************************************************
  */
 
 NSPR_API(PRInt32)    PR_Send(PRFileDesc *fd, const void *buf, PRInt32 amount,
                                 PRIntn flags, PRIntervalTime timeout);
 
+#if defined(ENABLE_SCTP)
+ /*
+  *************************************************************************
+ * FUNCTION: PR_SctpSendmsg
+ * DESCRIPTION:
+ *    Send a specified number of bytes from a connected socket.
+ *     The operation will block until all bytes are
+ *     processed, a time out has occurred, or there is an error.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing a socket.
+ *     void *msg
+ *       pointer to a buffer containing the data
+ *     PRInt32 msgsz
+ *       the amount of data in msg (in bytes)
+ *     PRNetAddr *to
+ *        pointer to address of peer endpoint
+ *     PRUint32 tolen
+ *       length of peer endpoint address structure
+ *     PRInt32 ppid
+ *       payload protocol identifier to be passed to chunk
+ *     PRInt32 flags
+ *       flags to identify SCTP options
+ *     PRInt16 stream,
+ *       stream number on which to send data
+ *     PRInt32 timetolive
+ *       lifetime of message in milliseconds (0 = infinite lifetime)
+ *     PRInt32 context
+ *       user context to associate with local application-specific context
+ *       on failed transmission
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *     A positive number indicates the number of bytes successfully processed.
+ *     This number must always equal 'amount'. A -1 is an indication that the
+ *     operation failed. The reason for the failure is obtained by calling
+ *     PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32)    PR_SctpSendmsg(PRFileDesc *fd, const void *buf,
+    PRInt32 msgsz, const PRNetAddr *to, PRUint32 tolen, PRInt32 ppid,
+    PRUint32 flags, PRInt16 stream, PRInt32 timetolive, PRInt32 context,
+    PRIntervalTime timeout);
+#endif
+
 /*
  *************************************************************************
  * FUNCTION: PR_RecvFrom
  * DESCRIPTION:
  *     Receive up to a specified number of bytes from socket which may
  *     or may not be connected.
  *     The operation will block until one or more bytes are 
  *     transferred, a time out has occurred, or there is an error. 
diff --git a/nsprpub/pr/include/private/pprio.h b/nsprpub/pr/include/private/pprio.h
--- a/nsprpub/pr/include/private/pprio.h
+++ b/nsprpub/pr/include/private/pprio.h
@@ -26,16 +26,19 @@ typedef __int64 PROsfd;
 typedef PRInt32 PROsfd;
 #endif
 
 /* Return the method tables for files, tcp sockets and udp sockets */
 NSPR_API(const PRIOMethods*)    PR_GetFileMethods(void);
 NSPR_API(const PRIOMethods*)    PR_GetTCPMethods(void);
 NSPR_API(const PRIOMethods*)    PR_GetUDPMethods(void);
 NSPR_API(const PRIOMethods*)    PR_GetPipeMethods(void);
+#if defined(ENABLE_SCTP)
+NSPR_API(const PRIOMethods*)    PR_GetSCTPOneToOneMethods(void);
+#endif
 
 /*
 ** Convert a NSPR socket handle to a native socket handle.
 **
 ** Using this function makes your code depend on the properties of the
 ** current NSPR implementation, which may change (although extremely
 ** unlikely because of NSPR's backward compatibility requirement).  Avoid
 ** using it if you can.
diff --git a/nsprpub/pr/include/private/primpl.h b/nsprpub/pr/include/private/primpl.h
--- a/nsprpub/pr/include/private/primpl.h
+++ b/nsprpub/pr/include/private/primpl.h
@@ -183,16 +183,30 @@ typedef struct PTDebug
     PRUintn locks_created, locks_destroyed;
     PRUintn locks_acquired, locks_released;
     PRUintn cvars_created, cvars_destroyed;
     PRUintn cvars_notified, delayed_cv_deletes;
 } PTDebug;
 
 #endif /* defined(DEBUG) */
 
+#if defined (ENABLE_SCTP)
+extern PRInt32 _PR_MD_SCTP_RECVMSG(int osfd, void *buf, PRInt32 amount,
+                                   PRNetAddr *from, PRUint32 *fromlen,
+                                   PRSctp_SndRcvInfo *sinfo,
+                                   PRInt32 *msg_flags);
+#define _PR_MD_SCTP_RECVMSG          _MD_SCTP_RECVMSG
+extern PRInt32 _PR_MD_SCTPGETSOCKETOPTION(PRFileDesc *fd,
+                                          PRSocketOptionData *data);
+#define _PR_MD_SCTPGETSOCKETOPTION   _MD_SCTPGETSOCKETOPTION
+extern PRInt32 _PR_MD_SCTPSETSOCKETOPTION(PRFileDesc *fd,
+                                          const PRSocketOptionData *data);
+#define _PR_MD_SCTPSETSOCKETOPTION   _MD_SCTPSETSOCKETOPTION
+#endif
+
 NSPR_API(void) PT_FPrintStats(PRFileDesc *fd, const char *msg);
 
 /*
  * On Linux and its derivatives POSIX priority scheduling works only for
  * real-time threads. On those platforms we set thread's nice values
  * instead which requires us to track kernel thread IDs for each POSIX
  * thread we create.
  */
diff --git a/nsprpub/pr/include/prsctp.h b/nsprpub/pr/include/prsctp.h
new file mode 100644
--- /dev/null
+++ b/nsprpub/pr/include/prsctp.h
@@ -0,0 +1,158 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 	
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Jonathan T. Leighton <leighton@cis.udel.edu> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * File:        prsctp.h
+ *
+ * Description: NSPR versions of SCTP data structures.  Structure definitions were
+ *              chosen to match the -19 version of the SCTP Socket API ID.  Hopefully
+ *              once the ID is finalized it will bring better alignment between the
+ *              various platforms.
+ *
+ */
+
+#ifndef prsctp_h__
+#define prsctp_h__
+
+#if defined(ENABLE_SCTP)
+/* Need this to define the platform dependent opaque sctp_assoc_t structure.  */
+#include <netinet/sctp.h>
+
+typedef struct PRSctp_SndRcvInfo {
+        PRUint16      sinfo_stream;
+        PRUint16      sinfo_ssn;
+        PRUint16      sinfo_flags;
+        PRUint32      sinfo_ppid;
+        PRUint32      sinfo_context;
+        PRUint32      sinfo_pr_value;             /* sinfo_timetolive on all platforms */
+        PRUint32      sinfo_tsn;
+        PRUint32      sinfo_cumtsn;
+        sctp_assoc_t  sinfo_assoc_id;
+} PRSctp_SndRcvInfo;
+
+typedef struct PRSctp_ExtRcvInfo {                /* Doesn't exist on Linux or Solaris */
+        PRSctp_SndRcvInfo  serinfo_sinfo;         /* yet...                            */
+        PRUint16           serinfo_next_flags;
+        PRUint16           serinfo_next_stream;
+        PRUint32           serinfo_next_aid;
+        PRUint32           serinfo_next_length;
+        PRUint32           serinfo_next_ppid;
+} PRSctp_ExtRcvInfo;
+
+typedef struct PRSctp_Event_Subscribe {
+        PRUint8  sctp_data_io_event;
+        PRUint8  sctp_association_event;
+        PRUint8  sctp_address_event;
+        PRUint8  sctp_send_failure_event;
+        PRUint8  sctp_peer_error_event;
+        PRUint8  sctp_shutdown_event;
+        PRUint8  sctp_partial_delivery_event;
+        PRUint8  sctp_adaptation_layer_event;     /* Spelled "adaption" on Solaris */
+        PRUint8  sctp_authentication_event;       /* Member doesn't exist on Solaris */
+        PRUint8  sctp_sender_dry_event;           /* Member exists only on FreeBSD 7.2. */
+                                                  /* Darwin and other FreeBSDs > 7.0    */
+                                                  /* have sctp_stream_reset_events      */
+                                                  /* instead.  So... sender_dry_event   */
+                                                  /* is only supported on FreeBSD 7.2   */
+                                                  /* and stream_reset_events is not     */
+                                                  /* supported on any platform, yet...  */
+} PRSctp_Event_Subscribe;
+
+typedef struct PRSctp_InitMsg {
+        PRUint16  sinit_num_ostreams;             /* uint32_t on Darwin and FreeBSD */
+        PRUint16  sinit_max_instreams;            /* uint32_t on Darwin and FreeBSD */
+        PRUint16  sinit_max_attempts;
+        PRUint16  sinit_max_init_timeo;
+} PRSctp_InitMsg;
+
+typedef struct PRSctp_PAddrInfo {
+        sctp_assoc_t             spinfo_assoc_id; /* assoc_id and address in reverse */
+        PRNetAddr                spinfo_address;  /* order on FreeBSD and Darwin */
+        PRInt32                  spinfo_state;
+        PRUint32                 spinfo_cwnd;
+        PRUint32                 spinfo_srtt;
+        PRUint32                 spinfo_rto;
+        PRUint32                 spinfo_mtu;
+} PRSctp_PAddrInfo;
+
+typedef struct PRSctp_Status {
+        sctp_assoc_t             sstat_assoc_id;
+        PRInt32                  sstat_state;
+        PRUint32                 sstat_rwnd;
+        PRUint16                 sstat_unackdata;
+        PRUint16                 sstat_penddata;
+        PRUint16                 sstat_instrms;
+        PRUint16                 sstat_outstrms;
+        PRUint32                 sstat_fragmentation_point;
+        struct PRSctp_PAddrInfo  sstat_primary;
+} PRSctp_Status;
+
+typedef struct PRSctp_AssocParams {               /* Member order is very different on */
+        sctp_assoc_t  sasoc_assoc_id;             /* FreeBSD and Darwin                */
+        PRUint16      sasoc_asocmaxrxt;
+        PRUint16      sasoc_number_peer_destinations;
+        PRUint32      sasoc_peer_rwnd;
+        PRUint32      sasoc_local_rwnd;
+        PRUint32      sasoc_cookie_life;
+} PRSctp_AssocParams;
+
+typedef struct PRSctp_SetPrim {                   /* Member order reversed on FreeBSD */
+        sctp_assoc_t             ssp_assoc_id;    /* and Darwin.                      */
+        PRNetAddr                ssp_addr;
+} PRSctp_SetPrim;
+
+typedef struct PRSctp_SetPeerPrim {               /* Member order reversed on FreeBSD */
+        sctp_assoc_t             sspp_assoc_id;   /* and Darwin.                      */
+        PRNetAddr                sspp_addr;
+} PRSctp_SetPeerPrim;
+
+typedef struct PRSctp_Assoc_Value {               /* Doesn't exist on Solaris */
+        sctp_assoc_t  assoc_id;
+        PRUint32      assoc_value;
+} PRSctp_Assoc_Value;
+
+#else /* ! ENABLE_SCTP */
+
+/* Dummy definition */
+typedef struct PRSctp_SndRcvInfo {
+        PRUint32     nosctp;
+} PRSctp_SndRcvInfo;
+
+#endif /* ! ENABLE_SCTP */
+
+#endif /* prsctp_h__ */
diff --git a/nsprpub/pr/src/Makefile.in b/nsprpub/pr/src/Makefile.in
--- a/nsprpub/pr/src/Makefile.in
+++ b/nsprpub/pr/src/Makefile.in
@@ -178,16 +178,20 @@ endif
 ifeq ($(OS_TARGET),Android)
 OS_LIBS		+= -llog
 endif
 
 ifeq ($(OS_TARGET),MacOSX)
 OS_LIBS		= -framework CoreServices -framework CoreFoundation
 endif
 
+ifdef USE_LIBSCTP
+EXTRA_LIBS += -lsctp
+endif
+
 EXTRA_LIBS += $(OS_LIBS)
 
 #
 # Define platform-dependent OBJS
 #
 
 OBJS = \
     $(OBJDIR)/prvrsion.$(OBJ_SUFFIX) \
diff --git a/nsprpub/pr/src/io/prfile.c b/nsprpub/pr/src/io/prfile.c
--- a/nsprpub/pr/src/io/prfile.c
+++ b/nsprpub/pr/src/io/prfile.c
@@ -241,19 +241,24 @@ static PRIOMethods _pr_fileMethods = {
     (PRRecvFN)_PR_InvalidInt,		
     (PRSendFN)_PR_InvalidInt,		
     (PRRecvfromFN)_PR_InvalidInt,	
     (PRSendtoFN)_PR_InvalidInt,		
     FilePoll,         
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,	
-    (PRGetpeernameFN)_PR_InvalidStatus,	
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsg) _PR_InvalidInt,
+    (PRSctp_sendmsg) _PR_InvalidInt,
+#else
     (PRReservedFN)_PR_InvalidInt,	
-    (PRReservedFN)_PR_InvalidInt,	
+    (PRReservedFN)_PR_InvalidInt,
+#endif	
     (PRGetsocketoptionFN)_PR_InvalidStatus,	
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
@@ -285,19 +290,24 @@ static PRIOMethods _pr_pipeMethods = {
     (PRRecvFN)_PR_InvalidInt,		
     (PRSendFN)_PR_InvalidInt,		
     (PRRecvfromFN)_PR_InvalidInt,	
     (PRSendtoFN)_PR_InvalidInt,		
     FilePoll,         
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,	
-    (PRGetpeernameFN)_PR_InvalidStatus,	
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsg) _PR_InvalidInt,		
+    (PRSctp_sendmsg) _PR_InvalidInt,
+#else
     (PRReservedFN)_PR_InvalidInt,	
-    (PRReservedFN)_PR_InvalidInt,	
+    (PRReservedFN)_PR_InvalidInt,
+#endif	
     (PRGetsocketoptionFN)_PR_InvalidStatus,	
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
diff --git a/nsprpub/pr/src/io/priometh.c b/nsprpub/pr/src/io/priometh.c
--- a/nsprpub/pr/src/io/priometh.c
+++ b/nsprpub/pr/src/io/priometh.c
@@ -31,19 +31,24 @@ PRIOMethods _pr_faulty_methods = {
     (PRRecvFN)_PR_InvalidInt,        
     (PRSendFN)_PR_InvalidInt,        
     (PRRecvfromFN)_PR_InvalidInt,    
     (PRSendtoFN)_PR_InvalidInt,        
     (PRPollFN)_PR_InvalidInt16,
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,    
-    (PRGetpeernameFN)_PR_InvalidStatus,    
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else   
     (PRReservedFN)_PR_InvalidInt,    
-    (PRReservedFN)_PR_InvalidInt,    
+    (PRReservedFN)_PR_InvalidInt,
+#endif   
     (PRGetsocketoptionFN)_PR_InvalidStatus,
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt
@@ -183,22 +188,39 @@ PR_IMPLEMENT(PRStatus) PR_Listen(PRFileD
 }
 
 PR_IMPLEMENT(PRInt32) PR_Recv(PRFileDesc *fd, void *buf, PRInt32 amount,
 PRIntn flags, PRIntervalTime timeout)
 {
 	return((fd->methods->recv)(fd,buf,amount,flags,timeout));
 }
 
+#if defined(ENABLE_SCTP)
+PR_IMPLEMENT(PRInt32) PR_SctpRecvmsg(PRFileDesc *fd, void *msg, PRInt32 msgsz,
+    PRNetAddr *from, PRUint32 *fromlen, PRSctp_SndRcvInfo *sinfo, PRInt32 *msg_flags, PRIntervalTime timeout)
+{
+        return((fd->methods->sctp_recvmsg)(fd,msg,msgsz,from,fromlen,sinfo,msg_flags, timeout));
+}
+#endif
+
 PR_IMPLEMENT(PRInt32) PR_Send(PRFileDesc *fd, const void *buf, PRInt32 amount,
 PRIntn flags, PRIntervalTime timeout)
 {
 	return((fd->methods->send)(fd,buf,amount,flags,timeout));
 }
 
+#if defined(ENABLE_SCTP)
+PR_IMPLEMENT(PRInt32) PR_SctpSendmsg(PRFileDesc *fd, const void *msg, PRInt32 msgsz,
+    const PRNetAddr *to, PRUint32 tolen, PRInt32 ppid, PRUint32 flags, PRInt16 stream,
+    PRInt32 timetolive, PRInt32 context, PRIntervalTime timeout)
+{
+        return((fd->methods->sctp_sendmsg)(fd,msg,msgsz,to,tolen,ppid,flags,stream,timetolive,context,PR_INTERVAL_NO_TIMEOUT));
+}
+#endif
+
 PR_IMPLEMENT(PRInt32) PR_Writev(PRFileDesc *fd, const PRIOVec *iov,
 PRInt32 iov_size, PRIntervalTime timeout)
 {
     if (iov_size > PR_MAX_IOVECTOR_SIZE)
     {
         PR_SetError(PR_BUFFER_OVERFLOW_ERROR, 0);
         return -1;
     }
diff --git a/nsprpub/pr/src/io/prlayer.c b/nsprpub/pr/src/io/prlayer.c
--- a/nsprpub/pr/src/io/prlayer.c
+++ b/nsprpub/pr/src/io/prlayer.c
@@ -356,16 +356,44 @@ static PRStatus PR_CALLBACK pl_DefGetsoc
 static PRStatus PR_CALLBACK pl_DefGetpeername (PRFileDesc *fd, PRNetAddr *addr)
 {
     PR_ASSERT(fd != NULL);
     PR_ASSERT(fd->lower != NULL);
 
     return (fd->lower->methods->getpeername)(fd->lower, addr);
 }
 
+#if defined(ENABLE_SCTP)
+static PRInt32 PR_CALLBACK pl_DefSctp_recvmsg (
+    PRFileDesc *fd, void *buf,
+    PRInt32 amount, PRNetAddr *from, PRUint32 *fromlen,
+    PRSctp_SndRcvInfo *sinfo, PRInt32 *msgflags,
+    PRIntervalTime timeout)
+{
+    PR_ASSERT(fd != NULL);
+    PR_ASSERT(fd->lower != NULL);
+
+    return (fd->lower->methods->sctp_recvmsg)(
+        fd->lower, buf, amount, from, fromlen, sinfo, msgflags, timeout);
+}
+
+static PRInt32 PR_CALLBACK pl_DefSctp_sendmsg (
+    PRFileDesc *fd, const void *buf,
+    PRInt32 amount, const PRNetAddr *to, PRUint32 tolen, PRInt32 ppid,
+    PRUint32 flags, PRInt16 stream, PRInt32 timetolive, PRInt32 context,
+    PRIntervalTime timeout)
+{
+    PR_ASSERT(fd != NULL);
+    PR_ASSERT(fd->lower != NULL);
+    return (fd->lower->methods->sctp_sendmsg)(
+        fd->lower, buf, amount, to, tolen, ppid, flags, stream, timetolive,
+        context, timeout);
+}
+#endif
+
 static PRStatus PR_CALLBACK pl_DefGetsocketoption (
     PRFileDesc *fd, PRSocketOptionData *data)
 {
     PR_ASSERT(fd != NULL);
     PR_ASSERT(fd->lower != NULL);
 
     return (fd->lower->methods->getsocketoption)(fd->lower, data);
 }
@@ -413,18 +441,23 @@ static PRIOMethods pl_methods = {
     pl_DefSend,
     pl_DefRecvfrom,
     pl_DefSendto,
     pl_DefPoll,
     pl_DefAcceptread,
     pl_DefTransmitfile,
     pl_DefGetsockname,
     pl_DefGetpeername,
+#if defined(ENABLE_SCTP)
+    pl_DefSctp_recvmsg,
+    pl_DefSctp_sendmsg,
+#else
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
+#endif
     pl_DefGetsocketoption,
     pl_DefSetsocketoption,
     pl_DefSendfile,
     pl_DefConnectcontinue,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt
diff --git a/nsprpub/pr/src/io/prmapopt.c b/nsprpub/pr/src/io/prmapopt.c
--- a/nsprpub/pr/src/io/prmapopt.c
+++ b/nsprpub/pr/src/io/prmapopt.c
@@ -417,31 +417,84 @@ PRStatus PR_CALLBACK _PR_SocketSetSocket
 #ifndef SO_BROADCAST                    /* enable broadcast on UDP sockets  */
 #define SO_BROADCAST        _PR_NO_SUCH_SOCKOPT
 #endif
 
 #ifndef SO_REUSEPORT                    /* allow local address & port reuse */
 #define SO_REUSEPORT        _PR_NO_SUCH_SOCKOPT
 #endif
 
+#if defined(ENABLE_SCTP)
+#ifndef SCTP_DEFAULT_SEND_PARAM         /* set default outgoing parameters and */
+#define SCTP_DEFAULT_SEND_PARAM  _PR_NO_SUCH_SOCKOPT  /* get incoming msg info */
+#endif
+
+#ifndef SCTP_USE_EXT_RCVINFO            /* enable/disable extrcvinfo messages */
+#define SCTP_USE_EXT_RCVINFO     _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_EVENTS                     /* enable/disable sndrcvinfo messages */
+#define SCTP_EVENTS         _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_INITMSG                    /* get/set INIT chunk parameters*/
+#define SCTP_INITMSG        _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_ASSOCINFO                  /* get/set/change association info */
+#define SCTP_ASSOCINFO      _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_NODELAY                    /* enable/disable Nagle algorithm */
+#define SCTP_NODELAY        _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_MAXSEG                     /* set/get maximum fragment size */
+#define SCTP_MAXSEG         _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_STATUS                     /* get current state of association */
+#define SCTP_STATUS         _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_SET_PEER_PRIMARY_ADDR      /* set peer's primary address */
+#define SCTP_SET_PEER_PRIMARY_ADDR  _PR_NO_SUCH_SOCKOPT
+#endif
+
+#ifndef SCTP_SET_PRIMARY_ADDR           /* set primary address */
+#define SCTP_SET_PRIMARY_ADDR  _PR_NO_SUCH_SOCKOPT
+#endif
+#endif
+
 PRStatus _PR_MapOptionName(
     PRSockOption optname, PRInt32 *level, PRInt32 *name)
 {
     static PRInt32 socketOptions[PR_SockOpt_Last] =
     {
         0, SO_LINGER, SO_REUSEADDR, SO_KEEPALIVE, SO_RCVBUF, SO_SNDBUF,
         IP_TTL, IP_TOS, IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP,
         IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_LOOP,
+#if defined(ENABLE_SCTP)
+        TCP_NODELAY, TCP_MAXSEG, SO_BROADCAST, SO_REUSEPORT,
+        SCTP_DEFAULT_SEND_PARAM, SCTP_USE_EXT_RCVINFO, SCTP_EVENTS, 
+        SCTP_INITMSG, SCTP_ASSOCINFO, SCTP_NODELAY, SCTP_MAXSEG, 
+        SCTP_STATUS, SCTP_SET_PEER_PRIMARY_ADDR, SCTP_SET_PRIMARY_ADDR,
+#endif
         TCP_NODELAY, TCP_MAXSEG, SO_BROADCAST, SO_REUSEPORT
     };
     static PRInt32 socketLevels[PR_SockOpt_Last] =
     {
         0, SOL_SOCKET, SOL_SOCKET, SOL_SOCKET, SOL_SOCKET, SOL_SOCKET,
         IPPROTO_IP, IPPROTO_IP, IPPROTO_IP, IPPROTO_IP,
         IPPROTO_IP, IPPROTO_IP, IPPROTO_IP,
+#if defined(ENABLE_SCTP)
+        IPPROTO_TCP, IPPROTO_TCP, SOL_SOCKET, SOL_SOCKET, IPPROTO_SCTP,
+        IPPROTO_SCTP, IPPROTO_SCTP, IPPROTO_SCTP, IPPROTO_SCTP,	
+        IPPROTO_SCTP, IPPROTO_SCTP, IPPROTO_SCTP, IPPROTO_SCTP, IPPROTO_SCTP,
+#endif
         IPPROTO_TCP, IPPROTO_TCP, SOL_SOCKET, SOL_SOCKET
     };
 
     if ((optname < PR_SockOpt_Linger)
     || (optname >= PR_SockOpt_Last))
     {
         PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
         return PR_FAILURE;
diff --git a/nsprpub/pr/src/io/prpolevt.c b/nsprpub/pr/src/io/prpolevt.c
--- a/nsprpub/pr/src/io/prpolevt.c
+++ b/nsprpub/pr/src/io/prpolevt.c
@@ -71,19 +71,24 @@ static PRIOMethods _pr_polevt_methods = 
     (PRRecvFN)_PR_InvalidInt,        
     (PRSendFN)_PR_InvalidInt,        
     (PRRecvfromFN)_PR_InvalidInt,    
     (PRSendtoFN)_PR_InvalidInt,        
     _pr_PolEvtPoll,
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,    
-    (PRGetpeernameFN)_PR_InvalidStatus,    
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else    
     (PRReservedFN)_PR_InvalidInt,    
-    (PRReservedFN)_PR_InvalidInt,    
+    (PRReservedFN)_PR_InvalidInt,
+#endif    
     (PRGetsocketoptionFN)_PR_InvalidStatus,
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
diff --git a/nsprpub/pr/src/md/unix/darwin.c b/nsprpub/pr/src/md/unix/darwin.c
--- a/nsprpub/pr/src/md/unix/darwin.c
+++ b/nsprpub/pr/src/md/unix/darwin.c
@@ -1,14 +1,15 @@
 /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "primpl.h"
+#include <string.h>
 
 #include <mach/mach_time.h>
 
 void _MD_EarlyInit(void)
 {
 }
 
 /*
@@ -53,17 +54,406 @@ PRWord *_MD_HomeGCRegisters(PRThread *t,
     *np = sizeof(CONTEXT(t)) / sizeof(PRWord);
     return (PRWord *) CONTEXT(t);
 #else
 	*np = 0;
 	return NULL;
 #endif
 }
 
-#if !defined(_PR_PTHREADS)
+#if defined(_PR_PTHREADS)
+#if defined(ENABLE_SCTP)
+PRInt32 _MD_Sctp_Recvmsg(
+    int                  osfd,
+    void                *buf,
+    PRInt32              amount,
+    PRNetAddr           *from,
+    PRUint32            *fromlen,
+    PRSctp_SndRcvInfo   *sinfo,
+    PRInt32             *msg_flags)
+{
+    PRInt32 bytes;
+    PRInt32 optval;
+    PRUint32 length;
+    PRSctp_ExtRcvInfo *serinfo=(PRSctp_ExtRcvInfo *)sinfo;
+    struct sctp_extrcvinfo md_serinfo;
+    struct sctp_sndrcvinfo *md_sinfo=(struct sctp_sndrcvinfo *)&md_serinfo;
+
+    memset(&md_serinfo, 0, sizeof(md_serinfo));
+    bytes = sctp_recvmsg(           osfd,
+                                    buf,
+                                    amount,
+                 (struct sockaddr*) from,
+                                    fromlen,
+        (struct sctp_sndrcvinfo *) &md_serinfo,
+                                    msg_flags);
+
+    /* must check for SCTP_USE_EXT_RCVINFO */
+    length = sizeof(optval);
+    if (getsockopt(osfd, IPPROTO_SCTP, SCTP_USE_EXT_RCVINFO, (void *)&optval, &length)) {
+        return -1;
+    }
+
+    if (optval) {          /* we are using extended receive info. */
+        serinfo->serinfo_sinfo.sinfo_stream    = md_serinfo.sinfo_stream;
+        serinfo->serinfo_sinfo.sinfo_ssn       = md_serinfo.sinfo_ssn;
+        serinfo->serinfo_sinfo.sinfo_flags     = md_serinfo.sinfo_flags;
+        serinfo->serinfo_sinfo.sinfo_ppid      = md_serinfo.sinfo_ppid;
+        serinfo->serinfo_sinfo.sinfo_context   = md_serinfo.sinfo_context;
+        serinfo->serinfo_sinfo.sinfo_pr_value  = md_serinfo.sinfo_timetolive;
+        serinfo->serinfo_sinfo.sinfo_tsn       = md_serinfo.sinfo_tsn;
+        serinfo->serinfo_sinfo.sinfo_cumtsn    = md_serinfo.sinfo_cumtsn;
+        serinfo->serinfo_sinfo.sinfo_assoc_id  = md_serinfo.sinfo_assoc_id;
+        serinfo->serinfo_next_flags            = md_serinfo.sreinfo_next_flags;
+        serinfo->serinfo_next_stream           = md_serinfo.sreinfo_next_stream;
+        serinfo->serinfo_next_aid              = md_serinfo.sreinfo_next_aid;
+        serinfo->serinfo_next_length           = md_serinfo.sreinfo_next_length;
+        serinfo->serinfo_next_ppid             = md_serinfo.sreinfo_next_ppid;
+    }
+    else {                /* we are not using extended receive info. */
+        sinfo->sinfo_stream    = md_sinfo->sinfo_stream;
+        sinfo->sinfo_ssn       = md_sinfo->sinfo_ssn;
+        sinfo->sinfo_flags     = md_sinfo->sinfo_flags;
+        sinfo->sinfo_ppid      = md_sinfo->sinfo_ppid;
+        sinfo->sinfo_context   = md_sinfo->sinfo_context;
+        sinfo->sinfo_pr_value  = md_sinfo->sinfo_timetolive;
+        sinfo->sinfo_tsn       = md_sinfo->sinfo_tsn;
+        sinfo->sinfo_cumtsn    = md_sinfo->sinfo_cumtsn;
+        sinfo->sinfo_assoc_id  = md_sinfo->sinfo_assoc_id;
+    }
+
+    return bytes;
+}
+
+PRInt32 _MD_SCTPGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv = 0;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+               /*
+                * On Darwin we can't use PRSctp_SndRcvInfo because the native
+                * structure contains padding for 64 bit alignment.
+                */
+                struct sctp_sndrcvinfo md_sndrcvinfo;
+                length = sizeof(md_sndrcvinfo);
+                memset(&md_sndrcvinfo, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_sndrcvinfo,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_sndrcvinfo) == length));
+                data->value.sndrcvinfo.sinfo_stream    = md_sndrcvinfo.sinfo_stream;
+                data->value.sndrcvinfo.sinfo_ssn       = md_sndrcvinfo.sinfo_ssn;
+                data->value.sndrcvinfo.sinfo_flags     = md_sndrcvinfo.sinfo_flags;
+                data->value.sndrcvinfo.sinfo_ppid      = md_sndrcvinfo.sinfo_ppid;
+                data->value.sndrcvinfo.sinfo_context   = md_sndrcvinfo.sinfo_context;
+                data->value.sndrcvinfo.sinfo_pr_value  = md_sndrcvinfo.sinfo_timetolive;
+                data->value.sndrcvinfo.sinfo_tsn       = md_sndrcvinfo.sinfo_tsn;
+                data->value.sndrcvinfo.sinfo_cumtsn    = md_sndrcvinfo.sinfo_cumtsn;
+                data->value.sndrcvinfo.sinfo_assoc_id  = md_sndrcvinfo.sinfo_assoc_id;
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe md_events;  /* Use native structure in case */
+                length = sizeof(md_events);             /* it's larger than NSPR's      */
+                memset(&md_events, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_events, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_events) == length));
+                data->value.events.sctp_data_io_event =
+                    md_events.sctp_data_io_event;
+                data->value.events.sctp_association_event =
+                    md_events.sctp_association_event;
+                data->value.events.sctp_address_event =
+                    md_events.sctp_address_event;
+                data->value.events.sctp_send_failure_event =
+                    md_events.sctp_send_failure_event;
+                data->value.events.sctp_peer_error_event =
+                    md_events.sctp_peer_error_event;
+                data->value.events.sctp_shutdown_event =
+                    md_events.sctp_shutdown_event;
+                data->value.events.sctp_partial_delivery_event =
+                    md_events.sctp_partial_delivery_event;
+                data->value.events.sctp_adaptation_layer_event =
+                    md_events.sctp_adaptation_layer_event;
+                data->value.events.sctp_authentication_event =
+                    md_events.sctp_authentication_event;
+                data->value.events.sctp_sender_dry_event =
+                    md_events.sctp_sender_dry_event;
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                struct sctp_initmsg md_initmsg;
+                length = sizeof(md_initmsg);
+                memset(&md_initmsg, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_initmsg,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_initmsg) == length));
+                data->value.initmsg.sinit_num_ostreams   =
+                    md_initmsg.sinit_num_ostreams;
+                data->value.initmsg.sinit_max_instreams  =
+                    md_initmsg.sinit_max_instreams;
+                data->value.initmsg.sinit_max_attempts   =
+                    md_initmsg.sinit_max_attempts;
+                data->value.initmsg.sinit_max_init_timeo =
+                    md_initmsg.sinit_max_init_timeo;
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                struct sctp_assocparams md_assocparams;
+                length = sizeof(md_assocparams);
+                memset(&md_assocparams, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_assocparams,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_assocparams) == length));
+                data->value.assocparams.sasoc_assoc_id =
+                    md_assocparams.sasoc_assoc_id;
+                data->value.assocparams.sasoc_asocmaxrxt =
+                    md_assocparams.sasoc_asocmaxrxt;
+                data->value.assocparams.sasoc_number_peer_destinations =
+                    md_assocparams.sasoc_number_peer_destinations;
+                data->value.assocparams.sasoc_peer_rwnd =
+                    md_assocparams.sasoc_peer_rwnd;
+                data->value.assocparams.sasoc_local_rwnd =
+                    md_assocparams.sasoc_local_rwnd;
+                data->value.assocparams.sasoc_cookie_life =
+                    md_assocparams.sasoc_cookie_life;
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&sctp_maxseg, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(sctp_maxseg) == length));
+                data->value.sctp_maxseg.assoc_id = sctp_maxseg.assoc_id;
+                data->value.sctp_maxseg.assoc_value = sctp_maxseg.assoc_value;
+                break;
+            }
+            case PR_SockOpt_Status:
+            {
+                struct sctp_status md_status;
+                length = sizeof(md_status);
+                memset(&md_status, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&md_status, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_status) == length));
+                data->value.status.sstat_assoc_id  = md_status.sstat_assoc_id;
+                data->value.status.sstat_state     = md_status.sstat_state;
+                data->value.status.sstat_rwnd      = md_status.sstat_rwnd;
+                data->value.status.sstat_unackdata = md_status.sstat_unackdata;
+                data->value.status.sstat_penddata  = md_status.sstat_penddata;
+                data->value.status.sstat_instrms   = md_status.sstat_instrms;
+                data->value.status.sstat_outstrms  = md_status.sstat_outstrms;
+                data->value.status.sstat_fragmentation_point =
+                         md_status.sstat_fragmentation_point;
+                /* Can't memcpy data->value.status.sstat_primary because    */
+                /* data->value.status.sstat_primary.spinfo_address is type  */
+                /* PRNetAddr, while md_status.sstat_primary.spinfo_address  */
+                /* is the much larger sockaddr_storage.                     */
+                data->value.status.sstat_primary.spinfo_assoc_id =
+                         md_status.sstat_primary.spinfo_assoc_id;
+                memcpy(&(data->value.status.sstat_primary.spinfo_address),
+                    &(md_status.sstat_primary.spinfo_address), sizeof(PRNetAddr));
+                /* PRNetAddr is based on the 4.3BSD compatible sockaddr_in6 */
+                /* structure, while Darwin uses the 4.4BSD sockaddr_in6    */
+               /* structure, so we must correct PRNetAddr.family after     */
+                /* copying the sockaddr_storage structure.                  */
+                data->value.status.sstat_primary.spinfo_address.raw.family =
+                         md_status.sstat_primary.spinfo_address.ss_family;
+                data->value.status.sstat_primary.spinfo_state =
+                         md_status.sstat_primary.spinfo_state;
+                data->value.status.sstat_primary.spinfo_cwnd =
+                         md_status.sstat_primary.spinfo_cwnd;
+                data->value.status.sstat_primary.spinfo_srtt =
+                         md_status.sstat_primary.spinfo_srtt;
+                data->value.status.sstat_primary.spinfo_rto =
+                         md_status.sstat_primary.spinfo_rto;
+                data->value.status.sstat_primary.spinfo_mtu =
+                         md_status.sstat_primary.spinfo_mtu;
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE */
+}
+
+PRInt32 _MD_SCTPSetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv = 0;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+                PRSctp_SndRcvInfo sndrcvinfo;
+                length = sizeof(sndrcvinfo);
+                memset(&sndrcvinfo, 0, length);
+                sndrcvinfo.sinfo_stream     = data->value.sndrcvinfo.sinfo_stream;
+                sndrcvinfo.sinfo_ssn        = data->value.sndrcvinfo.sinfo_ssn;
+                sndrcvinfo.sinfo_flags      = data->value.sndrcvinfo.sinfo_flags;
+                sndrcvinfo.sinfo_ppid       = data->value.sndrcvinfo.sinfo_ppid;
+                sndrcvinfo.sinfo_context    = data->value.sndrcvinfo.sinfo_context;
+                sndrcvinfo.sinfo_pr_value   = data->value.sndrcvinfo.sinfo_pr_value;
+                sndrcvinfo.sinfo_tsn        = data->value.sndrcvinfo.sinfo_tsn;
+                sndrcvinfo.sinfo_cumtsn     = data->value.sndrcvinfo.sinfo_cumtsn;
+                sndrcvinfo.sinfo_assoc_id   = data->value.sndrcvinfo.sinfo_assoc_id;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&sndrcvinfo,
+                                length);
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe events;  /* Use native structure in case */
+                length = sizeof(events);             /* it's larger than NSPR's      */
+                memset(&events, 0, length);
+                events.sctp_data_io_event =
+                    data->value.events.sctp_data_io_event;
+                events.sctp_association_event =
+                    data->value.events.sctp_association_event;
+                events.sctp_address_event =
+                    data->value.events.sctp_address_event;
+                events.sctp_send_failure_event =
+                    data->value.events.sctp_send_failure_event;
+                events.sctp_peer_error_event =
+                    data->value.events.sctp_peer_error_event;
+                events.sctp_shutdown_event =
+                    data->value.events.sctp_shutdown_event;
+                events.sctp_partial_delivery_event =
+                    data->value.events.sctp_partial_delivery_event;
+                events.sctp_adaptation_layer_event =
+                    data->value.events.sctp_adaptation_layer_event;
+                events.sctp_authentication_event =
+                    data->value.events.sctp_authentication_event;
+                events.sctp_sender_dry_event =
+                    data->value.events.sctp_sender_dry_event;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&events,
+                                length);
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                struct sctp_initmsg md_initmsg;
+                length = sizeof(md_initmsg);
+                memset(&md_initmsg, 0, length);
+                md_initmsg.sinit_num_ostreams   =
+                    data->value.initmsg.sinit_num_ostreams;
+                md_initmsg.sinit_max_instreams  =
+                    data->value.initmsg.sinit_max_instreams;
+                md_initmsg.sinit_max_attempts   =
+                    data->value.initmsg.sinit_max_attempts;
+                md_initmsg.sinit_max_init_timeo =
+                    data->value.initmsg.sinit_max_init_timeo;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_initmsg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                struct sctp_assocparams md_assocparams;
+                length = sizeof(md_assocparams);
+                memset(&md_assocparams, 0, length);
+                md_assocparams.sasoc_assoc_id =
+                    data->value.assocparams.sasoc_assoc_id;
+                md_assocparams.sasoc_asocmaxrxt =
+                    data->value.assocparams.sasoc_asocmaxrxt;
+                md_assocparams.sasoc_number_peer_destinations =
+                    data->value.assocparams.sasoc_number_peer_destinations;
+                md_assocparams.sasoc_peer_rwnd =
+                    data->value.assocparams.sasoc_peer_rwnd;
+                md_assocparams.sasoc_local_rwnd =
+                    data->value.assocparams.sasoc_local_rwnd;
+                md_assocparams.sasoc_cookie_life =
+                    data->value.assocparams.sasoc_cookie_life;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_assocparams,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                sctp_maxseg.assoc_id = data->value.sctp_maxseg.assoc_id;
+                sctp_maxseg.assoc_value = data->value.sctp_maxseg.assoc_value;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&sctp_maxseg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPeerPrimaryAddr:
+            {
+                struct sctp_setpeerprim md_setpeerprim;
+                length = sizeof(md_setpeerprim);
+                memset(&md_setpeerprim, 0, length);
+                md_setpeerprim.sspp_assoc_id = data->value.setpeerprim.sspp_assoc_id;
+                memcpy(&(md_setpeerprim.sspp_addr),
+                       &(data->value.setpeerprim.sspp_addr), sizeof(PRNetAddr));
+                /* Manually set ss_len.  Note that NSPR only supports ipv4 and ipv6. */
+                if (AF_INET == data->value.setpeerprim.sspp_addr.raw.family)
+                    md_setpeerprim.sspp_addr.ss_len = sizeof(struct sockaddr_in);
+                else
+                    md_setpeerprim.sspp_addr.ss_len = sizeof(struct sockaddr_in6);
+                /* Must correct ss_family after memcpy. */
+                md_setpeerprim.sspp_addr.ss_family =
+                    data->value.setpeerprim.sspp_addr.raw.family;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setpeerprim,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPrimaryAddr:
+            {
+                struct sctp_setprim md_setprim;
+                length = sizeof(md_setprim);
+                memset(&md_setprim, 0, length);
+                md_setprim.ssp_assoc_id = data->value.setprim.ssp_assoc_id;
+                memcpy(&(md_setprim.ssp_addr),
+                       &(data->value.setprim.ssp_addr), sizeof(PRNetAddr));
+                /* Manually set ss_len.  Note that NSPR only supports ipv4 and ipv6. */
+                if (AF_INET == data->value.setprim.ssp_addr.raw.family)
+                    md_setprim.ssp_addr.ss_len = sizeof(struct sockaddr_in);
+                else
+                    md_setprim.ssp_addr.ss_len = sizeof(struct sockaddr_in6);
+                /* Must correct ss_family after memcpy. */
+                md_setprim.ssp_addr.ss_family =
+                    data->value.setprim.ssp_addr.raw.family;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setprim,
+                                length);
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE - should never happen here. */
+}
+#endif /* ENABLE_SCTP */
+#else /* ! _PR_PTHREADS */
 void
 _MD_SET_PRIORITY(_MDThread *thread, PRUintn newPri)
 {
     return;
 }
 
 PRStatus
 _MD_InitializeThread(PRThread *thread)
diff --git a/nsprpub/pr/src/md/unix/freebsd.c b/nsprpub/pr/src/md/unix/freebsd.c
--- a/nsprpub/pr/src/md/unix/freebsd.c
+++ b/nsprpub/pr/src/md/unix/freebsd.c
@@ -30,17 +30,416 @@ PRWord *_MD_HomeGCRegisters(PRThread *t,
     *np = sizeof(CONTEXT(t)) / sizeof(PRWord);
     return (PRWord *) CONTEXT(t);
 #else
 	*np = 0;
 	return NULL;
 #endif
 }
 
-#ifndef _PR_PTHREADS
+
+#if defined(_PR_PTHREADS)
+#if defined(ENABLE_SCTP)
+PRInt32 _MD_Sctp_Recvmsg(
+    int                  osfd,
+    void                *buf,
+    PRInt32              amount,
+    PRNetAddr           *from,
+    PRUint32            *fromlen,
+    PRSctp_SndRcvInfo   *sinfo,
+    PRInt32             *msg_flags)
+{
+    PRInt32 bytes;
+    PRInt32 optval;
+    PRUint32 length;
+    PRSctp_ExtRcvInfo *serinfo=(PRSctp_ExtRcvInfo *)sinfo;
+    struct sctp_extrcvinfo md_serinfo;
+    struct sctp_sndrcvinfo *md_sinfo=(struct sctp_sndrcvinfo *)&md_serinfo;
+
+    memset(&md_serinfo, 0, sizeof(md_serinfo));
+    bytes = sctp_recvmsg(           osfd,
+                                    buf,
+                                    amount,
+                 (struct sockaddr*) from,
+                                    fromlen,
+        (struct sctp_sndrcvinfo *) &md_serinfo,
+                                    msg_flags);
+
+    /* must check for SCTP_USE_EXT_RCVINFO */
+    length = sizeof(optval);
+    if (getsockopt(osfd, IPPROTO_SCTP, SCTP_USE_EXT_RCVINFO, (void *)&optval, &length)) {
+        return -1;
+    }
+
+    if (optval) {          /* we are using extended receive info. */
+        serinfo->serinfo_sinfo.sinfo_stream    = md_serinfo.sinfo_stream;
+        serinfo->serinfo_sinfo.sinfo_ssn       = md_serinfo.sinfo_ssn;
+        serinfo->serinfo_sinfo.sinfo_flags     = md_serinfo.sinfo_flags;
+        serinfo->serinfo_sinfo.sinfo_ppid      = md_serinfo.sinfo_ppid;
+        serinfo->serinfo_sinfo.sinfo_context   = md_serinfo.sinfo_context;
+        serinfo->serinfo_sinfo.sinfo_pr_value  = md_serinfo.sinfo_timetolive;
+        serinfo->serinfo_sinfo.sinfo_tsn       = md_serinfo.sinfo_tsn;
+        serinfo->serinfo_sinfo.sinfo_cumtsn    = md_serinfo.sinfo_cumtsn;
+        serinfo->serinfo_sinfo.sinfo_assoc_id  = md_serinfo.sinfo_assoc_id;
+        serinfo->serinfo_next_flags            = md_serinfo.sreinfo_next_flags;
+        serinfo->serinfo_next_stream           = md_serinfo.sreinfo_next_stream;
+        serinfo->serinfo_next_aid              = md_serinfo.sreinfo_next_aid;
+        serinfo->serinfo_next_length           = md_serinfo.sreinfo_next_length;
+        serinfo->serinfo_next_ppid             = md_serinfo.sreinfo_next_ppid;
+    }
+    else {                /* we are not using extended receive info. */
+        sinfo->sinfo_stream    = md_sinfo->sinfo_stream;
+        sinfo->sinfo_ssn       = md_sinfo->sinfo_ssn;
+        sinfo->sinfo_flags     = md_sinfo->sinfo_flags;
+        sinfo->sinfo_ppid      = md_sinfo->sinfo_ppid;
+        sinfo->sinfo_context   = md_sinfo->sinfo_context;
+        sinfo->sinfo_pr_value  = md_sinfo->sinfo_timetolive;
+        sinfo->sinfo_tsn       = md_sinfo->sinfo_tsn;
+        sinfo->sinfo_cumtsn    = md_sinfo->sinfo_cumtsn;
+        sinfo->sinfo_assoc_id  = md_sinfo->sinfo_assoc_id;
+    }
+
+    return bytes;
+}
+
+PRInt32 _MD_SCTPGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+               /*
+                * On FreeBSD we can't use PRSctp_SndRcvInfo because the native
+                * structure contains padding for 64 bit alignment.
+                */
+                struct sctp_sndrcvinfo md_sndrcvinfo;
+                length = sizeof(md_sndrcvinfo);
+                memset(&md_sndrcvinfo, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_sndrcvinfo,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_sndrcvinfo) == length));
+                data->value.sndrcvinfo.sinfo_stream    = md_sndrcvinfo.sinfo_stream;
+                data->value.sndrcvinfo.sinfo_ssn       = md_sndrcvinfo.sinfo_ssn;
+                data->value.sndrcvinfo.sinfo_flags     = md_sndrcvinfo.sinfo_flags;
+                data->value.sndrcvinfo.sinfo_ppid      = md_sndrcvinfo.sinfo_ppid;
+                data->value.sndrcvinfo.sinfo_context   = md_sndrcvinfo.sinfo_context;
+                data->value.sndrcvinfo.sinfo_pr_value  = md_sndrcvinfo.sinfo_timetolive;
+                data->value.sndrcvinfo.sinfo_tsn       = md_sndrcvinfo.sinfo_tsn;
+                data->value.sndrcvinfo.sinfo_cumtsn    = md_sndrcvinfo.sinfo_cumtsn;
+                data->value.sndrcvinfo.sinfo_assoc_id  = md_sndrcvinfo.sinfo_assoc_id;
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe md_events;  /* Use native structure in case */
+                length = sizeof(md_events);             /* this is FreeBSD 7.2.         */
+                memset(&md_events, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_events, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_events) == length));
+                data->value.events.sctp_data_io_event =
+                    md_events.sctp_data_io_event;
+                data->value.events.sctp_association_event =
+                    md_events.sctp_association_event;
+                data->value.events.sctp_address_event =
+                    md_events.sctp_address_event;
+                data->value.events.sctp_send_failure_event =
+                    md_events.sctp_send_failure_event;
+                data->value.events.sctp_peer_error_event =
+                    md_events.sctp_peer_error_event;
+                data->value.events.sctp_shutdown_event =
+                    md_events.sctp_shutdown_event;
+                data->value.events.sctp_partial_delivery_event =
+                    md_events.sctp_partial_delivery_event;
+                data->value.events.sctp_adaptation_layer_event =
+                    md_events.sctp_adaptation_layer_event;
+                data->value.events.sctp_authentication_event =
+                    md_events.sctp_authentication_event;
+#if defined(SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS)
+                data->value.events.sctp_sender_dry_event =
+                    md_events.sctp_sender_dry_event;
+#else
+                data->value.events.sctp_sender_dry_event = 0;
+#endif
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                struct sctp_initmsg md_initmsg;
+                length = sizeof(md_initmsg);
+                memset(&md_initmsg, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_initmsg,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_initmsg) == length));
+                data->value.initmsg.sinit_num_ostreams   =
+                    md_initmsg.sinit_num_ostreams;
+                data->value.initmsg.sinit_max_instreams  =
+                    md_initmsg.sinit_max_instreams;
+                data->value.initmsg.sinit_max_attempts   =
+                    md_initmsg.sinit_max_attempts;
+                data->value.initmsg.sinit_max_init_timeo =
+                    md_initmsg.sinit_max_init_timeo;
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                struct sctp_assocparams md_assocparams;
+                length = sizeof(md_assocparams);
+                memset(&md_assocparams, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_assocparams,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_assocparams) == length));
+                data->value.assocparams.sasoc_assoc_id =
+                    md_assocparams.sasoc_assoc_id;
+                data->value.assocparams.sasoc_asocmaxrxt =
+                    md_assocparams.sasoc_asocmaxrxt;
+                data->value.assocparams.sasoc_number_peer_destinations =
+                    md_assocparams.sasoc_number_peer_destinations;
+                data->value.assocparams.sasoc_peer_rwnd =
+                    md_assocparams.sasoc_peer_rwnd;
+                data->value.assocparams.sasoc_local_rwnd =
+                    md_assocparams.sasoc_local_rwnd;
+                data->value.assocparams.sasoc_cookie_life =
+                    md_assocparams.sasoc_cookie_life;
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&sctp_maxseg, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(sctp_maxseg) == length));
+                data->value.sctp_maxseg.assoc_id = sctp_maxseg.assoc_id;
+                data->value.sctp_maxseg.assoc_value = sctp_maxseg.assoc_value;
+                break;
+            }
+            case PR_SockOpt_Status:
+            {
+                struct sctp_status md_status;
+                length = sizeof(md_status);
+                memset(&md_status, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&md_status, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_status) == length));
+                data->value.status.sstat_assoc_id  = md_status.sstat_assoc_id;
+                data->value.status.sstat_state     = md_status.sstat_state;
+                data->value.status.sstat_rwnd      = md_status.sstat_rwnd;
+                data->value.status.sstat_unackdata = md_status.sstat_unackdata;
+                data->value.status.sstat_penddata  = md_status.sstat_penddata;
+                data->value.status.sstat_instrms   = md_status.sstat_instrms;
+                data->value.status.sstat_outstrms  = md_status.sstat_outstrms;
+                data->value.status.sstat_fragmentation_point =
+                         md_status.sstat_fragmentation_point;
+                /* Can't memcpy data->value.status.sstat_primary because    */
+                /* data->value.status.sstat_primary.spinfo_address is type  */
+                /* PRNetAddr, while md_status.sstat_primary.spinfo_address  */
+                /* is the much larger sockaddr_storage.                     */
+                data->value.status.sstat_primary.spinfo_assoc_id =
+                         md_status.sstat_primary.spinfo_assoc_id;
+                memcpy(&(data->value.status.sstat_primary.spinfo_address),
+                    &(md_status.sstat_primary.spinfo_address), sizeof(PRNetAddr));
+                /* PRNetAddr is based on the 4.3BSD compatible sockaddr_in6 */
+                /* structure, while FreeBSD uses the 4.4BSD sockaddr_in6    */
+                /* structure, so we must correct PRNetAddr.family after     */
+                /* copying the sockaddr_storage structure.                  */
+                data->value.status.sstat_primary.spinfo_address.raw.family =
+                         md_status.sstat_primary.spinfo_address.ss_family;
+                data->value.status.sstat_primary.spinfo_state =
+                         md_status.sstat_primary.spinfo_state;
+                data->value.status.sstat_primary.spinfo_cwnd =
+                         md_status.sstat_primary.spinfo_cwnd;
+                data->value.status.sstat_primary.spinfo_srtt =
+                         md_status.sstat_primary.spinfo_srtt;
+                data->value.status.sstat_primary.spinfo_rto =
+                         md_status.sstat_primary.spinfo_rto;
+                data->value.status.sstat_primary.spinfo_mtu =
+                         md_status.sstat_primary.spinfo_mtu;
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE */
+}
+
+PRInt32 _MD_SCTPSetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+                PRSctp_SndRcvInfo sndrcvinfo;
+                length = sizeof(sndrcvinfo);
+                memset(&sndrcvinfo, 0, length);
+                sndrcvinfo.sinfo_stream     = data->value.sndrcvinfo.sinfo_stream;
+                sndrcvinfo.sinfo_ssn        = data->value.sndrcvinfo.sinfo_ssn;
+                sndrcvinfo.sinfo_flags      = data->value.sndrcvinfo.sinfo_flags;
+                sndrcvinfo.sinfo_ppid       = data->value.sndrcvinfo.sinfo_ppid;
+                sndrcvinfo.sinfo_context    = data->value.sndrcvinfo.sinfo_context;
+                sndrcvinfo.sinfo_pr_value   = data->value.sndrcvinfo.sinfo_pr_value;
+                sndrcvinfo.sinfo_tsn        = data->value.sndrcvinfo.sinfo_tsn;
+                sndrcvinfo.sinfo_cumtsn     = data->value.sndrcvinfo.sinfo_cumtsn;
+                sndrcvinfo.sinfo_assoc_id   = data->value.sndrcvinfo.sinfo_assoc_id;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&sndrcvinfo,
+                                length);
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe md_events;  /* Use native structure in case */
+                length = sizeof(md_events);             /* this is FreeBSD 7.2.         */
+                memset(&md_events, 0, length);
+                md_events.sctp_data_io_event =
+                    data->value.events.sctp_data_io_event;
+                md_events.sctp_association_event =
+                    data->value.events.sctp_association_event;
+                md_events.sctp_address_event =
+                    data->value.events.sctp_address_event;
+                md_events.sctp_send_failure_event =
+                    data->value.events.sctp_send_failure_event;
+                md_events.sctp_peer_error_event =
+                    data->value.events.sctp_peer_error_event;
+                md_events.sctp_shutdown_event =
+                    data->value.events.sctp_shutdown_event;
+                md_events.sctp_partial_delivery_event =
+                    data->value.events.sctp_partial_delivery_event;
+                md_events.sctp_adaptation_layer_event =
+                    data->value.events.sctp_adaptation_layer_event;
+                md_events.sctp_authentication_event =
+                    data->value.events.sctp_authentication_event;
+#if defined(SCTP_HAVE_DRY_EVENT_AND_RESET_EVENTS)
+                md_events.sctp_sender_dry_event =
+                    data->value.events.sctp_sender_dry_event;
+#endif
+                md_events.sctp_stream_reset_events = 0;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_events,
+                                length);
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                struct sctp_initmsg md_initmsg;
+                length = sizeof(md_initmsg);
+                memset(&md_initmsg, 0, length);
+                md_initmsg.sinit_num_ostreams   =
+                    data->value.initmsg.sinit_num_ostreams;
+                md_initmsg.sinit_max_instreams  =
+                    data->value.initmsg.sinit_max_instreams;
+                md_initmsg.sinit_max_attempts   =
+                    data->value.initmsg.sinit_max_attempts;
+                md_initmsg.sinit_max_init_timeo =
+                    data->value.initmsg.sinit_max_init_timeo;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_initmsg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                struct sctp_assocparams md_assocparams;
+                length = sizeof(md_assocparams);
+                memset(&md_assocparams, 0, length);
+                md_assocparams.sasoc_assoc_id =
+                    data->value.assocparams.sasoc_assoc_id;
+                md_assocparams.sasoc_asocmaxrxt =
+                    data->value.assocparams.sasoc_asocmaxrxt;
+                md_assocparams.sasoc_number_peer_destinations =
+                    data->value.assocparams.sasoc_number_peer_destinations;
+                md_assocparams.sasoc_peer_rwnd =
+                    data->value.assocparams.sasoc_peer_rwnd;
+                md_assocparams.sasoc_local_rwnd =
+                    data->value.assocparams.sasoc_local_rwnd;
+                md_assocparams.sasoc_cookie_life =
+                    data->value.assocparams.sasoc_cookie_life;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_assocparams,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                sctp_maxseg.assoc_id = data->value.sctp_maxseg.assoc_id;
+                sctp_maxseg.assoc_value = data->value.sctp_maxseg.assoc_value;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&sctp_maxseg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPeerPrimaryAddr:
+            {
+                struct sctp_setpeerprim md_setpeerprim;
+                length = sizeof(md_setpeerprim);
+                memset(&md_setpeerprim, 0, length);
+                md_setpeerprim.sspp_assoc_id = data->value.setpeerprim.sspp_assoc_id;
+                memcpy(&(md_setpeerprim.sspp_addr),
+                       &(data->value.setpeerprim.sspp_addr), sizeof(PRNetAddr));
+                /* Manually set ss_len.  Note that NSPR only supports ipv4 and ipv6. */
+                if (AF_INET == data->value.setpeerprim.sspp_addr.raw.family)
+                    md_setpeerprim.sspp_addr.ss_len = sizeof(struct sockaddr_in);
+                else
+                    md_setpeerprim.sspp_addr.ss_len = sizeof(struct sockaddr_in6);
+                /* Must correct ss_family after memcpy. */
+                md_setpeerprim.sspp_addr.ss_family =
+                    data->value.setpeerprim.sspp_addr.raw.family;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setpeerprim,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPrimaryAddr:
+            {
+                struct sctp_setprim md_setprim;
+                length = sizeof(md_setprim);
+                memset(&md_setprim, 0, length);
+                md_setprim.ssp_assoc_id = data->value.setprim.ssp_assoc_id;
+                memcpy(&(md_setprim.ssp_addr),
+                       &(data->value.setprim.ssp_addr), sizeof(PRNetAddr));
+                /* Manually set ss_len.  Note that NSPR only supports ipv4 and ipv6. */
+                if (AF_INET == data->value.setprim.ssp_addr.raw.family)
+                    md_setprim.ssp_addr.ss_len = sizeof(struct sockaddr_in);
+                else
+                    md_setprim.ssp_addr.ss_len = sizeof(struct sockaddr_in6);
+                /* Must correct ss_family after memcpy. */
+                md_setprim.ssp_addr.ss_family =
+                    data->value.setprim.ssp_addr.raw.family;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setprim,
+                                length);
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE - should never happen here. */
+}
+#endif /* ENABLE_SCTP */
+#else /* ! _PR_PTHREADS */
+
+
 void
 _MD_SET_PRIORITY(_MDThread *thread, PRUintn newPri)
 {
     return;
 }
 
 PRStatus
 _MD_InitializeThread(PRThread *thread)
diff --git a/nsprpub/pr/src/md/unix/linux.c b/nsprpub/pr/src/md/unix/linux.c
--- a/nsprpub/pr/src/md/unix/linux.c
+++ b/nsprpub/pr/src/md/unix/linux.c
@@ -27,16 +27,353 @@ PRWord *_MD_HomeGCRegisters(PRThread *t,
 
 extern void _MD_unix_terminate_waitpid_daemon(void);
 
 void _MD_CleanupBeforeExit(void)
 {
     _MD_unix_terminate_waitpid_daemon();
 }
 
+#if defined(ENABLE_SCTP)
+PRInt32 _MD_Sctp_Recvmsg(
+    int                  osfd,
+    void                *buf,
+    PRInt32              amount,
+    PRNetAddr           *from,
+    PRUint32            *fromlen,
+    PRSctp_SndRcvInfo   *sinfo,
+    PRInt32             *msg_flags)
+{
+    PRInt32 bytes;
+    struct sctp_sndrcvinfo md_sinfo;
+
+    memset(&md_sinfo, 0, sizeof(md_sinfo));
+    bytes = sctp_recvmsg(           osfd,
+                                    buf,
+                                    amount,
+                 (struct sockaddr*) from,
+                                    fromlen,
+                                   &md_sinfo,
+                                    msg_flags);
+
+    sinfo->sinfo_stream    = md_sinfo.sinfo_stream;
+    sinfo->sinfo_ssn       = md_sinfo.sinfo_ssn;
+    sinfo->sinfo_flags     = md_sinfo.sinfo_flags;
+    sinfo->sinfo_ppid      = md_sinfo.sinfo_ppid;
+    sinfo->sinfo_context   = md_sinfo.sinfo_context;
+    sinfo->sinfo_pr_value  = md_sinfo.sinfo_timetolive;
+    sinfo->sinfo_tsn       = md_sinfo.sinfo_tsn;
+    sinfo->sinfo_cumtsn    = md_sinfo.sinfo_cumtsn;
+    sinfo->sinfo_assoc_id  = md_sinfo.sinfo_assoc_id;
+
+    return bytes;
+}
+
+PRInt32 _MD_SCTPGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+                struct sctp_sndrcvinfo md_sndrcvinfo;
+                length = sizeof(md_sndrcvinfo);
+                memset(&md_sndrcvinfo, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_sndrcvinfo,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_sndrcvinfo) == length));
+                data->value.sndrcvinfo.sinfo_stream    = md_sndrcvinfo.sinfo_stream;
+                data->value.sndrcvinfo.sinfo_ssn       = md_sndrcvinfo.sinfo_ssn;
+                data->value.sndrcvinfo.sinfo_flags     = md_sndrcvinfo.sinfo_flags;
+                data->value.sndrcvinfo.sinfo_ppid      = md_sndrcvinfo.sinfo_ppid;
+                data->value.sndrcvinfo.sinfo_context   = md_sndrcvinfo.sinfo_context;
+                data->value.sndrcvinfo.sinfo_pr_value  = md_sndrcvinfo.sinfo_timetolive;
+                data->value.sndrcvinfo.sinfo_tsn       = md_sndrcvinfo.sinfo_tsn;
+                data->value.sndrcvinfo.sinfo_cumtsn    = md_sndrcvinfo.sinfo_cumtsn;
+                data->value.sndrcvinfo.sinfo_assoc_id  = md_sndrcvinfo.sinfo_assoc_id;
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe md_events;
+                length = sizeof(md_events);
+                memset(&md_events, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&md_events, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_events) == length));
+                data->value.events.sctp_data_io_event =
+                    md_events.sctp_data_io_event;
+                data->value.events.sctp_association_event =
+                    md_events.sctp_association_event;
+                data->value.events.sctp_address_event =
+                    md_events.sctp_address_event;
+                data->value.events.sctp_send_failure_event =
+                    md_events.sctp_send_failure_event;
+                data->value.events.sctp_peer_error_event =
+                    md_events.sctp_peer_error_event;
+                data->value.events.sctp_shutdown_event =
+                    md_events.sctp_shutdown_event;
+                data->value.events.sctp_partial_delivery_event =
+                    md_events.sctp_partial_delivery_event;
+                data->value.events.sctp_adaptation_layer_event =
+                    md_events.sctp_adaptation_layer_event;
+                data->value.events.sctp_authentication_event =
+                    md_events.sctp_authentication_event;
+                data->value.events.sctp_sender_dry_event = 0;
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                PRSctp_InitMsg initmsg;
+                length = sizeof(initmsg);
+                memset(&initmsg, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&initmsg,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(initmsg) == length));
+                data->value.initmsg.sinit_num_ostreams   =
+                    initmsg.sinit_num_ostreams;
+                data->value.initmsg.sinit_max_instreams  =
+                    initmsg.sinit_max_instreams;
+                data->value.initmsg.sinit_max_attempts   =
+                    initmsg.sinit_max_attempts;
+                data->value.initmsg.sinit_max_init_timeo =
+                    initmsg.sinit_max_init_timeo;
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                PRSctp_AssocParams assocparams;
+                length = sizeof(assocparams);
+                memset(&assocparams, 0, length);
+                rv = getsockopt(fd->secret->md.osfd, level, name, (void *)&assocparams,
+                                &length);
+                PR_ASSERT((-1 == rv) || (sizeof(assocparams) == length));
+                data->value.assocparams.sasoc_assoc_id =
+                    assocparams.sasoc_assoc_id;
+                data->value.assocparams.sasoc_asocmaxrxt =
+                    assocparams.sasoc_asocmaxrxt;
+                data->value.assocparams.sasoc_number_peer_destinations =
+                    assocparams.sasoc_number_peer_destinations;
+                data->value.assocparams.sasoc_peer_rwnd =
+                    assocparams.sasoc_peer_rwnd;
+                data->value.assocparams.sasoc_local_rwnd =
+                    assocparams.sasoc_local_rwnd;
+                data->value.assocparams.sasoc_cookie_life =
+                    assocparams.sasoc_cookie_life;
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&sctp_maxseg, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(sctp_maxseg) == length));
+                data->value.sctp_maxseg.assoc_id = sctp_maxseg.assoc_id;
+                data->value.sctp_maxseg.assoc_value = sctp_maxseg.assoc_value;
+                break;
+            }
+            case PR_SockOpt_Status:
+            {
+                struct sctp_status md_status;
+                length = sizeof(md_status);
+                memset(&md_status, 0, length);
+                rv = getsockopt(
+                    fd->secret->md.osfd, level, name, (void *)&md_status, &length);
+                PR_ASSERT((-1 == rv) || (sizeof(md_status) == length));
+                data->value.status.sstat_assoc_id  = md_status.sstat_assoc_id;
+                data->value.status.sstat_state     = md_status.sstat_state;
+                data->value.status.sstat_rwnd      = md_status.sstat_rwnd;
+                data->value.status.sstat_unackdata = md_status.sstat_unackdata;
+                data->value.status.sstat_penddata  = md_status.sstat_penddata;
+                data->value.status.sstat_instrms   = md_status.sstat_instrms;
+                data->value.status.sstat_outstrms  = md_status.sstat_outstrms;
+                data->value.status.sstat_fragmentation_point =
+                         md_status.sstat_fragmentation_point;
+                /* Can't memcpy data->value.status.sstat_primary because    */
+                /* data->value.status.sstat_primary.spinfo_address is type  */
+                /* PRNetAddr, while md_status.sstat_primary.spinfo_address  */
+                /* is the much larger sockaddr_storage.                     */
+                data->value.status.sstat_primary.spinfo_assoc_id =
+                         md_status.sstat_primary.spinfo_assoc_id;
+                memcpy(&(data->value.status.sstat_primary.spinfo_address),
+                    &(md_status.sstat_primary.spinfo_address), sizeof(PRNetAddr));
+                /* PRNetAddr is based on the 4.3BSD compatible sockaddr_in6 */
+                /* structure, which is also used by Linux, so there is no   */
+                /* need to correct PRNetAddr.family after copying the       */
+                /* sockaddr_storage structure.                              */
+                data->value.status.sstat_primary.spinfo_state =
+                         md_status.sstat_primary.spinfo_state;
+                data->value.status.sstat_primary.spinfo_cwnd =
+                         md_status.sstat_primary.spinfo_cwnd;
+                data->value.status.sstat_primary.spinfo_srtt =
+                         md_status.sstat_primary.spinfo_srtt;
+                data->value.status.sstat_primary.spinfo_rto =
+                         md_status.sstat_primary.spinfo_rto;
+                data->value.status.sstat_primary.spinfo_mtu =
+                         md_status.sstat_primary.spinfo_mtu;
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE */
+}
+
+PRInt32 _MD_SCTPSetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data)
+{
+    PRStatus result;
+    PRIntn rv;
+    PRInt32 level, name;
+    PRUint32 length;
+
+    result = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS == result)
+    {
+        switch (data->option)
+        {
+            case PR_SockOpt_DefaultSendParam:
+            {
+                struct sctp_sndrcvinfo md_sndrcvinfo;
+                length = sizeof(md_sndrcvinfo);
+                memset(&md_sndrcvinfo, 0, length);
+                md_sndrcvinfo.sinfo_stream     = data->value.sndrcvinfo.sinfo_stream;
+                md_sndrcvinfo.sinfo_ssn        = data->value.sndrcvinfo.sinfo_ssn;
+                md_sndrcvinfo.sinfo_flags      = data->value.sndrcvinfo.sinfo_flags;
+                md_sndrcvinfo.sinfo_ppid       = data->value.sndrcvinfo.sinfo_ppid;
+                md_sndrcvinfo.sinfo_context    = data->value.sndrcvinfo.sinfo_context;
+                md_sndrcvinfo.sinfo_timetolive = data->value.sndrcvinfo.sinfo_pr_value;
+                md_sndrcvinfo.sinfo_tsn        = data->value.sndrcvinfo.sinfo_tsn;
+                md_sndrcvinfo.sinfo_cumtsn     = data->value.sndrcvinfo.sinfo_cumtsn;
+                md_sndrcvinfo.sinfo_assoc_id   = data->value.sndrcvinfo.sinfo_assoc_id;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_sndrcvinfo,
+                                length);
+                break;
+            }
+            case PR_SockOpt_Events:
+            {
+                struct sctp_event_subscribe md_events;
+                length = sizeof(md_events);
+                memset(&md_events, 0, length);
+                md_events.sctp_data_io_event =
+                    data->value.events.sctp_data_io_event;
+                md_events.sctp_association_event =
+                    data->value.events.sctp_association_event;
+                md_events.sctp_address_event =
+                    data->value.events.sctp_address_event;
+                md_events.sctp_send_failure_event =
+                    data->value.events.sctp_send_failure_event;
+                md_events.sctp_peer_error_event =
+                    data->value.events.sctp_peer_error_event;
+                md_events.sctp_shutdown_event =
+                    data->value.events.sctp_shutdown_event;
+                md_events.sctp_partial_delivery_event =
+                    data->value.events.sctp_partial_delivery_event;
+                md_events.sctp_adaptation_layer_event =
+                    data->value.events.sctp_adaptation_layer_event;
+                md_events.sctp_authentication_event =
+                    data->value.events.sctp_authentication_event;
+                /* sender_dry_event not support on Linux */
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_events,
+                                length);
+                break;
+            }
+            case PR_SockOpt_InitMsg:
+            {
+                PRSctp_InitMsg initmsg;
+                length = sizeof(initmsg);
+                memset(&initmsg, 0, length);
+                initmsg.sinit_num_ostreams   =
+                    data->value.initmsg.sinit_num_ostreams;
+                initmsg.sinit_max_instreams  =
+                    data->value.initmsg.sinit_max_instreams;
+                initmsg.sinit_max_attempts   =
+                    data->value.initmsg.sinit_max_attempts;
+                initmsg.sinit_max_init_timeo =
+                    data->value.initmsg.sinit_max_init_timeo;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&initmsg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_AssocInfo:
+            {
+                PRSctp_AssocParams assocparams;
+                length = sizeof(assocparams);
+                memset(&assocparams, 0, length);
+                assocparams.sasoc_assoc_id =
+                    data->value.assocparams.sasoc_assoc_id;
+                assocparams.sasoc_asocmaxrxt =
+                    data->value.assocparams.sasoc_asocmaxrxt;
+                assocparams.sasoc_number_peer_destinations =
+                    data->value.assocparams.sasoc_number_peer_destinations;
+                assocparams.sasoc_peer_rwnd =
+                    data->value.assocparams.sasoc_peer_rwnd;
+                assocparams.sasoc_local_rwnd =
+                    data->value.assocparams.sasoc_local_rwnd;
+                assocparams.sasoc_cookie_life =
+                    data->value.assocparams.sasoc_cookie_life;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&assocparams,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SctpMaxSegment:
+            {
+                PRSctp_Assoc_Value sctp_maxseg;
+                length = sizeof(sctp_maxseg);
+                memset(&sctp_maxseg, 0, length);
+                sctp_maxseg.assoc_id = data->value.sctp_maxseg.assoc_id;
+                sctp_maxseg.assoc_value = data->value.sctp_maxseg.assoc_value;
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&sctp_maxseg,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPeerPrimaryAddr:
+            {
+                struct sctp_setpeerprim md_setpeerprim;
+                length = sizeof(md_setpeerprim);
+                memset(&md_setpeerprim, 0, length);
+                md_setpeerprim.sspp_assoc_id = data->value.setpeerprim.sspp_assoc_id;
+                memcpy(&(md_setpeerprim.sspp_addr),
+                       &(data->value.setpeerprim.sspp_addr), sizeof(PRNetAddr));
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setpeerprim,
+                                length);
+                break;
+            }
+            case PR_SockOpt_SetPrimaryAddr:
+            {
+                struct sctp_setprim md_setprim;
+                length = sizeof(md_setprim);
+                memset(&md_setprim, 0, length);
+                md_setprim.ssp_assoc_id = data->value.setprim.ssp_assoc_id;
+                memcpy(&(md_setprim.ssp_addr),
+                       &(data->value.setprim.ssp_addr), sizeof(PRNetAddr));
+                rv = setsockopt(fd->secret->md.osfd, level, name, (void *)&md_setprim,
+                                length);
+                break;
+            }
+            default:
+                PR_NOT_REACHED("Unknown socket option");
+                break;
+        }
+        return rv;
+    }
+    return -1;    /* PR_MapOptionName returned PR_FAILURE - should never happen here. */
+}
+#endif /* ENABLE_SCTP */
+
 #else /* ! _PR_PTHREADS */
 
 void
 _MD_SET_PRIORITY(_MDThread *thread, PRUintn newPri)
 {
     return;
 }
 
diff --git a/nsprpub/pr/src/nspr.def b/nsprpub/pr/src/nspr.def
--- a/nsprpub/pr/src/nspr.def
+++ b/nsprpub/pr/src/nspr.def
@@ -434,16 +434,20 @@ EXPORTS ;-
 		PR_GetPhysicalMemorySize;
 ;+} NSPR_4.5;
 ;+NSPR_4.7 {
 ;+	global:
 		PR_ParseTimeStringToExplodedTime;
 ;+} NSPR_4.6;
 ;+NSPR_4.8 {
 ;+	global:
+		PR_OpenSCTPSocket;
+		PR_OpenSCTPOneToOneSocket;
+		PR_SctpRecvmsg;
+		PR_SctpSendmsg;
 		PR_AssertCurrentThreadOwnsLock;
 		PR_AssertCurrentThreadInMonitor;
 ;+} NSPR_4.7;
 ;+NSPR_4.8.9 {
 ;+      global:
                 PR_GetVersion;
 ;+} NSPR_4.8;
 ;+NSPR_4.9.2 {
diff --git a/nsprpub/pr/src/pthreads/ptio.c b/nsprpub/pr/src/pthreads/ptio.c
--- a/nsprpub/pr/src/pthreads/ptio.c
+++ b/nsprpub/pr/src/pthreads/ptio.c
@@ -307,18 +307,39 @@ struct pt_Continuation
          */
 		struct file_spec {		
         	off_t offset;                       /* offset in file to send */
         	size_t nbytes;                      /* length of file data to send */
         	size_t st_size;                     /* file size */
 		} file_spec;
 #endif
     } arg3;
-    union { PRIntn flags; } arg4;           /* #4 - read/write flags */
-    union { PRNetAddr *addr; } arg5;        /* #5 - send/recv address */
+    union { PRIntn flags; 
+#if defined(ENABLE_SCTP)
+            PRNetAddr *addr;                /*    - send/recv addr for SCTP */
+#endif    
+    } arg4;                                 /* #4 - read/write flags */
+    union { PRNetAddr *addr;
+#if defined(ENABLE_SCTP)
+            PRUint32 addr_len;              /*    - send/recv addr len for SCTP */
+#endif    
+    } arg5;                                 /* #5 - send/recv address */
+    
+#if defined(ENABLE_SCTP)
+    union { PRSctp_SndRcvInfo *sinfo;       /* #6 - SCTP sndrcvinfo structure */
+            PRSctp_ExtRcvInfo *serinfo;
+            PRUint32 ppid;                  /*    - SCTP ppid for sctp_sendmsg */
+    } arg6;
+    union { PRUint32 flags;                 /* #7 - SCTP sctp_sendmsg flags */
+            PRInt32 *msg_flags;             /*    - SCTP sctp_recvmsg msg_flags */
+    } arg7;
+    union { PRInt16 stream; } arg8;         /* #8 - SCTP stream number for sctp_sendmsg */
+    union { PRUint32 timetolive; } arg9;    /* #9 - SCTP timetolive for sctp_sendmsg */
+    union { PRUint32 context; } arg10;      /* #10 - SCTP context for sctp_sendmsg */
+#endif
 
 #ifdef HPUX11
     /*
      * For sendfile()
      */
     int filedesc;                           /* descriptor of file to send */
     int nbytes_to_send;                     /* size of header and file */
 #endif  /* HPUX11 */
@@ -770,16 +791,37 @@ static PRBool pt_recv_cont(pt_Continuati
         op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);
 #endif
     op->syserrno = errno;
     return ((-1 == op->result.code) && 
             (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?
         PR_FALSE : PR_TRUE;
 }  /* pt_recv_cont */
 
+#if defined(ENABLE_SCTP)
+static PRBool pt_sctp_recvmsg_cont(pt_Continuation *op, PRInt16 revents)
+{
+   /*
+    * As with pt_recv_cont, any number of bytes will complete the operation.
+    */
+    op->result.code = _PR_MD_SCTP_RECVMSG(op->arg1.osfd,
+                                          op->arg2.buffer,
+                                          op->arg3.amount,
+                                          op->arg4.addr,
+                                        &(op->arg5.addr_len),
+                                          op->arg6.sinfo,
+                                          op->arg7.msg_flags);
+    op->syserrno = errno;
+
+    return ((-1 == op->result.code) &&
+            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?
+        PR_FALSE : PR_TRUE;
+}  /* pt_sctp_recvmsg_cont */
+#endif
+
 static PRBool pt_send_cont(pt_Continuation *op, PRInt16 revents)
 {
     PRIntn bytes;
 #if defined(SOLARIS)
     PRInt32 tmp_amount = op->arg3.amount;
 #endif
     /*
      * We want to write the entire amount out, no matter how many
@@ -824,16 +866,55 @@ retry:
     else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))
     {
         op->result.code = -1;
         return PR_TRUE;
     }
     else return PR_FALSE;
 }  /* pt_send_cont */
 
+#if defined(ENABLE_SCTP)
+static PRBool pt_sctp_sendmsg_cont(pt_Continuation *op, PRInt16 revents)
+{
+    PRIntn bytes;
+
+    bytes = sctp_sendmsg(        op->arg1.osfd,
+                                 op->arg2.buffer,
+                                 op->arg3.amount,
+        (const struct sockaddr*) op->arg4.addr,
+                     (socklen_t) op->arg5.addr_len,
+                                 op->arg6.ppid,
+                                 op->arg7.flags,
+                                 op->arg8.stream,
+                                 op->arg9.timetolive,
+                                 op->arg10.context);
+    op->syserrno = errno;
+
+   /*
+    * sctp_sendmsg() should be atomic and therefore byte counting should
+    * be unnecessary.  However, I don't know that sctp_sendmsg() _is_ in
+    * fact atomic on all supported platforms, so I'm leaving this in
+    * for now.
+    */
+    if (bytes >= 0) {              /* this is progress */
+        char *bp = (char*)op->arg2.buffer;
+        bp += bytes;               /* adjust the buffer pointer */
+        op->arg2.buffer = bp;
+        op->result.code += bytes;  /* accumulate the number sent */
+        op->arg3.amount -= bytes;  /* and reduce the required count */
+        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;
+    }
+    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno)) {
+        op->result.code = -1;
+        return PR_TRUE;
+    }
+    else return PR_FALSE;
+}  /* pt_sctp_sendmsg_cont */
+#endif
+
 static PRBool pt_write_cont(pt_Continuation *op, PRInt16 revents)
 {
     PRIntn bytes;
     /*
      * We want to write the entire amount out, no matter how many
      * tries it takes. Keep advancing the buffer and the decrementing
      * the amount until the amount goes away. Return the total bytes
      * (which should be the original amount) when finished (or an
@@ -1699,17 +1780,25 @@ static PRFileDesc* pt_Accept(
     {
         addr->raw.family = ((struct sockaddr*)addr)->sa_family;
     }
 #endif /* _PR_HAVE_SOCKADDR_LEN */
 #ifdef _PR_INET6
 	if (addr && (AF_INET6 == addr->raw.family))
         addr->raw.family = PR_AF_INET6;
 #endif
+#if defined(ENABLE_SCTP)
+    /*
+     * With SCTP enabled we cannot assume TCP, so we must get the file
+     * descriptor type.
+     */
+    newfd = pt_SetMethods(osfd, PR_GetDescType(fd), PR_TRUE, PR_FALSE);
+#else
     newfd = pt_SetMethods(osfd, PR_DESC_SOCKET_TCP, PR_TRUE, PR_FALSE);
+#endif
     if (newfd == NULL) close(osfd);  /* $$$ whoops! this doesn't work $$$ */
     else
     {
         PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
         PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);
 #ifdef LINUX
         /*
          * On Linux, experiments showed that the accepted sockets
@@ -1866,16 +1955,81 @@ static PRInt32 pt_Recv(
             syserrno = op.syserrno;
         }
     }
     if (bytes < 0)
         pt_MapError(_PR_MD_MAP_RECV_ERROR, syserrno);
     return bytes;
 }  /* pt_Recv */
 
+#if defined(ENABLE_SCTP)
+static PRInt32 pt_Sctp_Recvmsg(
+    PRFileDesc          *fd,
+    void                *buf,
+    PRInt32              amount,
+    PRNetAddr           *from,
+    PRUint32            *fromlen,
+    PRSctp_SndRcvInfo   *sinfo,
+    PRInt32             *msg_flags,
+    PRIntervalTime timeout)
+{
+    PRInt32 syserrno, bytes = -1; 	
+    PRInt32 osflags;
+
+    /* convert to OS flags */
+    if (PR_MSG_PEEK == *msg_flags)
+        *msg_flags = MSG_PEEK;
+    else if (0 != *msg_flags) {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return bytes;
+    }
+
+    if (pt_TestAbort()) return bytes;
+
+    bytes = _PR_MD_SCTP_RECVMSG(fd->secret->md.osfd,
+                                buf,
+                                amount,
+                                from,
+                                fromlen,
+                                sinfo,
+                                msg_flags);
+    syserrno = errno;
+    if ((bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)
+        && (!fd->secret->nonblocking))
+    {
+        if (PR_INTERVAL_NO_WAIT == timeout) {
+            syserrno = ETIMEDOUT;
+        }
+        else
+        {
+            pt_Continuation op;
+            op.arg1.osfd = fd->secret->md.osfd;
+            op.arg2.buffer = buf;
+            op.arg3.amount = amount;
+            op.arg4.addr = from;
+            if(from)
+                op.arg5.addr_len = *fromlen;
+            else
+                op.arg5.addr_len = 0;
+            op.arg6.sinfo = sinfo;
+            op.arg7.msg_flags = msg_flags;
+            op.timeout = timeout;
+            op.function = pt_sctp_recvmsg_cont;
+            op.event = POLLIN | POLLPRI;
+            bytes = pt_Continue(&op);
+            syserrno = op.syserrno;
+        }
+    }	
+    if (bytes < 0)
+        pt_MapError(_PR_MD_MAP_RECV_ERROR, syserrno);
+    return bytes;
+}  /* pt_Sctp_Recvmsg */
+#endif
+
+
 static PRInt32 pt_SocketRead(PRFileDesc *fd, void *buf, PRInt32 amount)
 {
     return pt_Recv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
 }  /* pt_SocketRead */
 
 static PRInt32 pt_Send(
     PRFileDesc *fd, const void *buf, PRInt32 amount,
     PRIntn flags, PRIntervalTime timeout)
@@ -1969,16 +2123,103 @@ retry:
         bytes = pt_Continue(&op);
         syserrno = op.syserrno;
     }
     if (bytes == -1)
         pt_MapError(_PR_MD_MAP_SEND_ERROR, syserrno);
     return bytes;
 }  /* pt_Send */
 
+#if defined(ENABLE_SCTP)
+static PRInt32 pt_Sctp_Sendmsg(
+    PRFileDesc       *fd,
+    const void       *msg,
+    PRInt32           msgsz,
+    const PRNetAddr  *to,
+    PRUint32          tolen,
+    PRInt32           ppid,
+    PRUint32          flags,
+    PRInt16           stream,
+    PRInt32           timetolive,
+    PRInt32           context,
+    PRIntervalTime    timeout)
+{
+    PRInt32 syserrno, bytes = -1;
+    PRBool fNeedContinue = PR_FALSE;
+
+    if (pt_TestAbort()) return bytes;
+
+    bytes = sctp_sendmsg(        fd->secret->md.osfd,
+                                 msg,
+                                 msgsz,
+       (const struct sockaddr *) to,
+                     (socklen_t) tolen,
+                                 ppid,
+                                 flags,
+                                 stream,
+                                 timetolive,
+                                 context
+                         );
+    syserrno = errno;
+
+    if ( (bytes >= 0) && (bytes < msgsz) && (!fd->secret->nonblocking) )
+    {
+        if (PR_INTERVAL_NO_WAIT == timeout)
+        {
+            bytes = -1;
+            syserrno = ETIMEDOUT;
+        }
+        else
+        {
+            msg = (char *) msg + bytes;
+            msgsz -= bytes;
+            fNeedContinue = PR_TRUE;
+        }
+    }
+    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)
+        && (!fd->secret->nonblocking) )
+    {
+        if (PR_INTERVAL_NO_WAIT == timeout) 
+            syserrno = ETIMEDOUT;
+        else
+        {
+            bytes = 0;
+            fNeedContinue = PR_TRUE;
+        }
+    }
+	
+    if (fNeedContinue == PR_TRUE)
+    {
+        pt_Continuation op;
+        op.arg1.osfd = fd->secret->md.osfd;
+        op.arg2.buffer = (void*)msg;
+        op.arg3.amount = msgsz;
+        op.arg4.addr = to;
+        op.arg5.addr_len = tolen;
+        op.arg6.ppid = ppid;
+        op.arg7.flags = flags;
+        op.arg8.stream = stream;
+        op.arg9.timetolive = timetolive;
+        op.arg10.context = context;
+        op.timeout = timeout;
+        op.result.code = bytes;  /* initialize the number sent */
+        op.function = pt_sctp_sendmsg_cont;
+        op.event = POLLOUT | POLLPRI;
+        bytes = pt_Continue(&op);
+        syserrno = op.syserrno;
+    }
+    if (bytes == -1) {
+        pt_MapError(_PR_MD_MAP_SEND_ERROR, syserrno);
+    }
+
+    return bytes;
+}  /* pt_Sctp_Sendmsg */
+#endif
+
+
 static PRInt32 pt_SocketWrite(PRFileDesc *fd, const void *buf, PRInt32 amount)
 {
     return pt_Send(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
 }  /* pt_SocketWrite */
 
 static PRInt32 pt_SendTo(
     PRFileDesc *fd, const void *buf,
     PRInt32 amount, PRIntn flags, const PRNetAddr *addr,
@@ -2850,16 +3091,20 @@ static PRStatus pt_GetSocketOption(PRFil
                     PR_SecondsToInterval(linger.l_linger);
                 break;
             }
             case PR_SockOpt_Reuseaddr:
             case PR_SockOpt_Keepalive:
             case PR_SockOpt_NoDelay:
             case PR_SockOpt_Broadcast:
             case PR_SockOpt_Reuseport:
+#if defined(ENABLE_SCTP)
+            case PR_SockOpt_UseExtRcvInfo:
+            case PR_SockOpt_SctpNoDelay:
+#endif
             {
                 PRIntn value;
                 length = sizeof(PRIntn);
                 rv = getsockopt(
                     fd->secret->md.osfd, level, name, (char*)&value, &length);
                 PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));
                 data->value.reuse_addr = (0 == value) ? PR_FALSE : PR_TRUE;
                 break;
@@ -2927,16 +3172,49 @@ static PRStatus pt_GetSocketOption(PRFil
                 length = sizeof(data->value.mcast_if.inet.ip);
                 rv = getsockopt(
                     fd->secret->md.osfd, level, name,
                     (char*)&data->value.mcast_if.inet.ip, &length);
                 PR_ASSERT((-1 == rv)
                     || (sizeof(data->value.mcast_if.inet.ip) == length));
                 break;
             }
+#if defined(ENABLE_SCTP)
+           /*
+            * Added support for the following SCTP socket options:
+            *     SCTP_DEFAULT_SEND_PARAM
+            *     SCTP_EVENTS
+            *     SCTP_INITMSG
+            *     SCTP_ASSOCINFO
+            *     SCTP_MAXSEG
+            *     SCTP_STATUS
+            *     SCTP_SET_PEER_PRIMARY_ADDR
+            *     SCTP_SET_PRIMARY_ADDR
+            */
+            case PR_SockOpt_DefaultSendParam:
+            case PR_SockOpt_Events:
+            case PR_SockOpt_InitMsg:
+            case PR_SockOpt_AssocInfo:
+            case PR_SockOpt_SctpMaxSegment:
+            case PR_SockOpt_Status:
+            {
+                rv = _PR_MD_SCTPGETSOCKETOPTION(fd, data);
+                break;
+            }
+            case PR_SockOpt_SetPeerPrimaryAddr:
+            {
+                PR_NOT_REACHED("SCTP_SET_PEER_PRIMARY_ADDR socket option is \"Set\" only");
+                break;
+            }
+            case PR_SockOpt_SetPrimaryAddr:
+            {
+                PR_NOT_REACHED("SCTP_SET_PRIMARY_ADDR socket option is \"Set\" only");
+                break;
+            }
+#endif
             default:
                 PR_NOT_REACHED("Unknown socket option");
                 break;
         }
         if (-1 == rv) _PR_MD_MAP_GETSOCKOPT_ERROR(errno);
     }
     return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;
 }  /* pt_GetSocketOption */
@@ -2970,16 +3248,20 @@ static PRStatus pt_SetSocketOption(PRFil
                     fd->secret->md.osfd, level, name, (char*)&linger, sizeof(linger));
                 break;
             }
             case PR_SockOpt_Reuseaddr:
             case PR_SockOpt_Keepalive:
             case PR_SockOpt_NoDelay:
             case PR_SockOpt_Broadcast:
             case PR_SockOpt_Reuseport:
+#if defined(ENABLE_SCTP)
+            case PR_SockOpt_UseExtRcvInfo:
+            case PR_SockOpt_SctpNoDelay:
+#endif
             {
                 PRIntn value = (data->value.reuse_addr) ? 1 : 0;
                 rv = setsockopt(
                     fd->secret->md.osfd, level, name,
                     (char*)&value, sizeof(PRIntn));
 #ifdef LINUX
                 /* for pt_LinuxSendFile */
                 if (name == TCP_NODELAY && rv == 0) {
@@ -3038,16 +3320,45 @@ static PRStatus pt_SetSocketOption(PRFil
             case PR_SockOpt_McastInterface:
             {
                 rv = setsockopt(
                     fd->secret->md.osfd, level, name,
                     (char*)&data->value.mcast_if.inet.ip,
                     sizeof(data->value.mcast_if.inet.ip));
                 break;
             }
+#if defined(ENABLE_SCTP)
+           /*
+            * Added support for the following SCTP socket options:
+            *     SCTP_DEFAULT_SEND_PARAM
+            *     SCTP_EVENTS
+            *     SCTP_INITMSG
+            *     SCTP_ASSOCINFO
+            *     SCTP_MAXSEG
+            *     SCTP_STATUS
+            *     SCTP_SET_PEER_PRIMARY_ADDRESS
+            *     SCTP_SET_PRIMARY_ADDRESS
+            */
+            case PR_SockOpt_DefaultSendParam:
+            case PR_SockOpt_Events:
+            case PR_SockOpt_InitMsg:
+            case PR_SockOpt_AssocInfo:
+            case PR_SockOpt_SctpMaxSegment:
+            case PR_SockOpt_SetPeerPrimaryAddr:
+            case PR_SockOpt_SetPrimaryAddr:
+            {
+                rv = _PR_MD_SCTPSETSOCKETOPTION(fd, data);
+                break;
+            }
+            case PR_SockOpt_Status:
+            {
+                PR_NOT_REACHED("SCTP_STATUS socket option is \"Get\" only");
+                break;
+            }
+#endif
             default:
                 PR_NOT_REACHED("Unknown socket option");
                 break;
         }
         if (-1 == rv) _PR_MD_MAP_SETSOCKOPT_ERROR(errno);
     }
     return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;
 }  /* pt_SetSocketOption */
@@ -3077,19 +3388,24 @@ static PRIOMethods _pr_file_methods = {
     (PRRecvFN)_PR_InvalidInt,        
     (PRSendFN)_PR_InvalidInt,        
     (PRRecvfromFN)_PR_InvalidInt,    
     (PRSendtoFN)_PR_InvalidInt,        
     pt_Poll,
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,    
-    (PRGetpeernameFN)_PR_InvalidStatus,    
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,    
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else  
     (PRReservedFN)_PR_InvalidInt,    
-    (PRReservedFN)_PR_InvalidInt,    
+    (PRReservedFN)_PR_InvalidInt,
+#endif   
     (PRGetsocketoptionFN)_PR_InvalidStatus,
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
@@ -3116,19 +3432,24 @@ static PRIOMethods _pr_pipe_methods = {
     (PRRecvFN)_PR_InvalidInt,        
     (PRSendFN)_PR_InvalidInt,        
     (PRRecvfromFN)_PR_InvalidInt,    
     (PRSendtoFN)_PR_InvalidInt,        
     pt_Poll,
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,    
-    (PRGetpeernameFN)_PR_InvalidStatus,    
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else    
     (PRReservedFN)_PR_InvalidInt,    
-    (PRReservedFN)_PR_InvalidInt,    
+    (PRReservedFN)_PR_InvalidInt,
+#endif    
     (PRGetsocketoptionFN)_PR_InvalidStatus,
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
@@ -3156,18 +3477,23 @@ static PRIOMethods _pr_tcp_methods = {
     pt_Send,
     (PRRecvfromFN)_PR_InvalidInt,
     (PRSendtoFN)_PR_InvalidInt,
     pt_Poll,
     pt_AcceptRead,
     pt_TransmitFile,
     pt_GetSockName,
     pt_GetPeerName,
+#if defined (ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
+#endif
     pt_GetSocketOption,
     pt_SetSocketOption,
     pt_SendFile, 
     pt_ConnectContinue,
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
@@ -3195,28 +3521,74 @@ static PRIOMethods _pr_udp_methods = {
     pt_Send,
     pt_RecvFrom,
     pt_SendTo,
     pt_Poll,
     (PRAcceptreadFN)_PR_InvalidInt,
     (PRTransmitfileFN)_PR_InvalidInt,
     pt_GetSockName,
     pt_GetPeerName,
+#if defined (ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else
     (PRReservedFN)_PR_InvalidInt,
     (PRReservedFN)_PR_InvalidInt,
+#endif
     pt_GetSocketOption,
     pt_SetSocketOption,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
 };
 
+#if defined(ENABLE_SCTP)
+static PRIOMethods _pr_sctp_methods_one_to_one = {
+    PR_DESC_SOCKET_SCTP_ONE_TO_ONE,
+    pt_Close,
+    pt_SocketRead,
+    pt_SocketWrite,
+    pt_Available_s,
+    pt_Available64_s,
+    pt_Synch,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    pt_Writev,
+    pt_Connect,
+    pt_Accept,
+    pt_Bind,
+    pt_Listen,
+    pt_Shutdown,
+    pt_Recv,
+    pt_Send,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    pt_Poll,
+    pt_AcceptRead,
+    pt_TransmitFile,
+    pt_GetSockName,
+    pt_GetPeerName,
+    pt_Sctp_Recvmsg,
+    pt_Sctp_Sendmsg,
+    pt_GetSocketOption,
+    pt_SetSocketOption,
+    pt_SendFile,
+    pt_ConnectContinue,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt
+};
+#endif
+
 static PRIOMethods _pr_socketpollfd_methods = {
     (PRDescType) 0,
     (PRCloseFN)_PR_InvalidStatus,
     (PRReadFN)_PR_InvalidInt,
     (PRWriteFN)_PR_InvalidInt,
     (PRAvailableFN)_PR_InvalidInt,
     (PRAvailable64FN)_PR_InvalidInt64,
     (PRFsyncFN)_PR_InvalidStatus,
@@ -3233,19 +3605,24 @@ static PRIOMethods _pr_socketpollfd_meth
     (PRRecvFN)_PR_InvalidInt,        
     (PRSendFN)_PR_InvalidInt,        
     (PRRecvfromFN)_PR_InvalidInt,    
     (PRSendtoFN)_PR_InvalidInt,        
 	pt_Poll,
     (PRAcceptreadFN)_PR_InvalidInt,   
     (PRTransmitfileFN)_PR_InvalidInt, 
     (PRGetsocknameFN)_PR_InvalidStatus,    
-    (PRGetpeernameFN)_PR_InvalidStatus,    
+    (PRGetpeernameFN)_PR_InvalidStatus,
+#if defined(ENABLE_SCTP)
+    (PRSctp_recvmsgFN)_PR_InvalidInt,
+    (PRSctp_sendmsgFN)_PR_InvalidInt,
+#else   
     (PRReservedFN)_PR_InvalidInt,    
-    (PRReservedFN)_PR_InvalidInt,    
+    (PRReservedFN)_PR_InvalidInt,
+#endif    
     (PRGetsocketoptionFN)_PR_InvalidStatus,
     (PRSetsocketoptionFN)_PR_InvalidStatus,
     (PRSendfileFN)_PR_InvalidInt, 
     (PRConnectcontinueFN)_PR_InvalidStatus, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt, 
     (PRReservedFN)_PR_InvalidInt
@@ -3334,16 +3711,26 @@ static PRFileDesc *pt_SetMethods(
             case PR_DESC_SOCKET_UDP:
                 fd->methods = PR_GetUDPMethods();
                 pt_MakeFdNonblock(osfd);
                 break;
             case PR_DESC_PIPE:
                 fd->methods = PR_GetPipeMethods();
                 pt_MakeFdNonblock(osfd);
                 break;
+#if defined(ENABLE_SCTP)
+            case PR_DESC_SOCKET_SCTP_ONE_TO_ONE:
+                fd->methods = PR_GetSCTPOneToOneMethods();
+#ifdef _PR_ACCEPT_INHERIT_NONBLOCK
+                if (!isAcceptedSocket) pt_MakeSocketNonblock(osfd);
+#else
+                pt_MakeSocketNonblock(osfd);
+#endif
+                break;
+#endif
             default:
                 break;
         }
     }
     return fd;
 }  /* pt_SetMethods */
 
 PR_IMPLEMENT(const PRIOMethods*) PR_GetFileMethods(void)
@@ -3361,16 +3748,23 @@ PR_IMPLEMENT(const PRIOMethods*) PR_GetT
     return &_pr_tcp_methods;
 }  /* PR_GetTCPMethods */
 
 PR_IMPLEMENT(const PRIOMethods*) PR_GetUDPMethods(void)
 {
     return &_pr_udp_methods;
 }  /* PR_GetUDPMethods */
 
+#if defined(ENABLE_SCTP)
+PR_IMPLEMENT(const PRIOMethods*) PR_GetSCTPOneToOneMethods(void)
+{
+    return &_pr_sctp_methods_one_to_one;
+}  /* PR_GetSCTPOneToOneMethods */
+#endif
+
 static const PRIOMethods* PR_GetSocketPollFdMethods(void)
 {
     return &_pr_socketpollfd_methods;
 }  /* PR_GetSocketPollFdMethods */
 
 PR_IMPLEMENT(PRFileDesc*) PR_AllocFileDesc(
     PRInt32 osfd, const PRIOMethods *methods)
 {
@@ -3380,16 +3774,19 @@ PR_IMPLEMENT(PRFileDesc*) PR_AllocFileDe
 
     fd->methods = methods;
     fd->secret->md.osfd = osfd;
     /* Make fd non-blocking */
     if (osfd > 2)
     {
         /* Don't mess around with stdin, stdout or stderr */
         if (&_pr_tcp_methods == methods) pt_MakeSocketNonblock(osfd);
+#if defined(ENABLE_SCTP)
+        else if (&_pr_sctp_methods_one_to_one == methods) pt_MakeSocketNonblock(osfd);
+#endif
         else pt_MakeFdNonblock(osfd);
     }
     fd->secret->state = _PR_FILEDESC_OPEN;
     fd->secret->inheritable = _PR_TRI_UNKNOWN;
     return fd;
     
 failed:
     PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
@@ -3453,18 +3850,27 @@ PR_IMPLEMENT(PRFileDesc*) PR_Socket(PRIn
         && PR_AF_INET6_SDP != domain
 #endif /* SOLARIS */
 #endif /* _PR_HAVE_SDP */
         && PF_UNIX != domain)
     {
         PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);
         return fd;
     }
-	if (type == SOCK_STREAM) ftype = PR_DESC_SOCKET_TCP;
-	else if (type == SOCK_DGRAM) ftype = PR_DESC_SOCKET_UDP;
+	if (type == SOCK_STREAM)
+#if defined(ENABLE_SCTP)
+    if(proto == IPPROTO_SCTP)
+        ftype = PR_DESC_SOCKET_SCTP_ONE_TO_ONE;
+    else
+        ftype = PR_DESC_SOCKET_TCP;
+#else	
+	ftype = PR_DESC_SOCKET_TCP;
+#endif
+	else if (type == SOCK_DGRAM)
+	    ftype = PR_DESC_SOCKET_UDP;
 	else
 	{
 		(void)PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);
 		return fd;
 	}
 #if defined(_PR_HAVE_SDP)
 #if defined(LINUX)
     if (PR_AF_INET_SDP == domain)
@@ -4372,17 +4778,29 @@ PR_IMPLEMENT(PRFileDesc*) PR_NewTCPSocke
 PR_IMPLEMENT(PRFileDesc*) PR_OpenUDPSocket(PRIntn af)
 {
     return PR_Socket(af, SOCK_DGRAM, 0);
 }  /* PR_NewUDPSocket */
 
 PR_IMPLEMENT(PRFileDesc*) PR_OpenTCPSocket(PRIntn af)
 {
     return PR_Socket(af, SOCK_STREAM, 0);
-}  /* PR_NewTCPSocket */
+}  /* PR_openTCPSocket */
+
+#if defined(ENABLE_SCTP)
+PR_IMPLEMENT(PRFileDesc*) PR_OpenSCTPSocket(PRIntn af, PRInt32 type)
+{
+    return PR_Socket(af, type, IPPROTO_SCTP);
+}  /* PR_OpenSCTPSocket */
+
+PR_IMPLEMENT(PRFileDesc*) PR_OpenSCTPOneToOneSocket(PRIntn af)
+{
+    return PR_Socket(af, SOCK_STREAM, IPPROTO_SCTP);
+}  /* PR_OpenSCTPOneToOneSocket */
+#endif
 
 PR_IMPLEMENT(PRStatus) PR_NewTCPSocketPair(PRFileDesc *fds[2])
 {
 #ifdef SYMBIAN
     /*
      * For the platforms that don't have socketpair.
      *
      * Copied from prsocket.c, with the parameter f[] renamed fds[] and the
diff --git a/nsprpub/pr/tests/Makefile.in b/nsprpub/pr/tests/Makefile.in
--- a/nsprpub/pr/tests/Makefile.in
+++ b/nsprpub/pr/tests/Makefile.in
@@ -10,16 +10,17 @@ MOD_DEPTH	= ../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(MOD_DEPTH)/config/autoconf.mk
 
 include $(topsrcdir)/config/config.mk
 
+
 DIRS = dll
 
 CSRCS =             \
 	accept.c		\
 	acceptread.c	\
 	acceptreademu.c	\
 	addrstr.c		\
 	affinity.c		\
@@ -187,16 +188,22 @@ endif
 ifeq ($(OS_TARGET),OS2)
 CSRCS +=            \
 	sleep.c			\
 	stat.c		    \
 	yield.c         \
 	$(NULL)
 endif
 
+ifeq ($(ENABLE_SCTP), 1)
+CSRCS +=            \
+         sctp.c     \
+         $(NULL)
+endif
+
 ifeq (,$(filter-out WINCE WINNT OS2,$(OS_ARCH)))
 PROG_SUFFIX = .exe
 DLL_SUFFIX = .dll
 else
 PROG_SUFFIX =
 DLL_SUFFIX = 
 endif
 
@@ -378,16 +385,21 @@ LIBPTHREAD = -ldce
 endif
 endif
 
 ifeq ($(OS_TARGET),Android)
 LIBPTHREAD =
 XCFLAGS = $(OS_CFLAGS)
 endif
 
+ifeq ($(USE_LIBSCTP),1)
+LDOPTS += -lsctp
+endif
+
+
 #####################################################
 #
 # The rules
 #
 #####################################################
 
 include $(topsrcdir)/config/rules.mk
 
diff --git a/nsprpub/pr/tests/sctp.c b/nsprpub/pr/tests/sctp.c
new file mode 100644
--- /dev/null
+++ b/nsprpub/pr/tests/sctp.c
@@ -0,0 +1,800 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/***********************************************************************
+ *
+ * Name: sctp.c
+ *
+ * Description: Test SCTP socket functionality.
+ *
+ * Modification History:
+ * 29-May-2009 - JLeighton - File created.  Code adapted from socket.c
+ */
+#include "primpl.h"
+
+#include "plgetopt.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#ifdef XP_UNIX
+#include <sys/mman.h>
+#endif
+#if defined(_PR_PTHREADS) && !defined(_PR_DCETHREADS)
+#include <pthread.h>
+#endif
+
+/*#include <process.h>*/
+
+static int _debug_on = 1;
+
+#include "obsolete/prsem.h"
+
+/*#define DPRINTF(arg) if (_debug_on) printf arg*/
+
+#define BUF_DATA_SIZE    (2 * 1024)
+#define SCTP_MESG_SIZE    1024
+
+#define NUM_SCTP_CLIENTS                  5    /* for a listen queue depth of 5 */
+#define NUM_SCTP_CONNECTIONS_PER_CLIENT   5
+#define NUM_SCTP_MESGS_PER_CONNECTION    10
+#define NUM_SCTP_STREAMS                 10
+#define SCTP_SERVER_PORT              10000
+#define SERVER_MAX_BIND_COUNT           100
+
+static PRInt32 num_sctp_clients = NUM_SCTP_CLIENTS;
+static PRInt32 num_sctp_connections_per_client = NUM_SCTP_CONNECTIONS_PER_CLIENT;
+static PRInt32 sctp_mesg_size = SCTP_MESG_SIZE;
+static PRInt32 num_sctp_mesgs_per_connection = NUM_SCTP_MESGS_PER_CONNECTION;
+
+static PRInt32 thread_count;
+PRUint16 server_domain = PR_AF_INET, client_domain = PR_AF_INET;
+
+int failed_already=0;
+typedef struct buffer {
+    char    data[BUF_DATA_SIZE];
+} buffer;
+
+PRNetAddr sctp_server_addr;
+
+typedef struct Serve_Client_Param {
+    PRFileDesc *sockfd;    /* socket to read from/write to */
+    PRInt32    datalen;    /* bytes of data transfered in each read/write */
+} Serve_Client_Param;
+
+typedef struct Server_Param {
+    PRMonitor *exit_mon;   /* monitor to signal on exit */
+    PRInt32 *exit_counter; /* counter to decrement, before exit */
+    PRInt32    datalen;    /* bytes of data transfered in each read/write */
+    PRLock *serv_lock;     /* lock for access to serv_cond */
+    PRCondVar *serv_cond;  /* cond variable to notify after setting up address */
+} Server_Param;
+
+typedef struct Client_Param {
+    PRNetAddr server_addr;
+    PRMonitor *exit_mon;   /* monitor to signal on exit */
+    PRInt32 *exit_counter; /* counter to decrement, before exit */
+    PRInt32    datalen;
+} Client_Param;
+
+/*
+ * readn
+ *    read data from sockfd into buf
+ */
+static PRInt32
+readn(PRFileDesc *sockfd, char *buf, int len, int *stream, int *msgflags)
+{
+    int rem=0;
+    int bytes=0;
+    int offset = 0;
+    PRSctp_SndRcvInfo sinfo;
+    PRIntervalTime timeout = PR_INTERVAL_NO_TIMEOUT;
+    PRThread *thrd = PR_GetCurrentThread();
+
+    memset(&sinfo, 0, sizeof(sinfo));
+    rem = len;
+    /* read until end of message or end of buffer space */
+    while (rem && !(*msgflags & MSG_EOR)) {
+        printf("0x%p: calling PR_SctpRecvmsg, bytes = %d\n", thrd, rem);
+        *msgflags = 0;
+        bytes = PR_SctpRecvmsg(sockfd, buf + offset, rem, NULL, 0,
+                               &sinfo, msgflags, timeout);
+        rem -= bytes;
+        *stream = sinfo.sinfo_stream;
+        printf("0x%p: returning from PR_SctpRecvmsg, bytes = %d\n", thrd, bytes);
+        if (bytes < 0) {
+            return -1;
+        }	
+    }
+    return len;
+}
+
+/*
+ * SCTP_Serve_Client
+ *    Thread, started by the server, for serving a client connection.
+ *    Reads data from socket and writes it back, unmodified, and
+ *    closes the socket
+ */
+static void PR_CALLBACK
+SCTP_Serve_Client(void *arg)
+{
+    Serve_Client_Param *scp = (Serve_Client_Param *) arg;
+    PRFileDesc *sockfd;
+    buffer *in_buf;
+    PRInt32 bytes, j, rv;
+    PRInt32 stream=0;
+    PRInt32 msg_flags=0;
+    PRSocketOptionData sod;
+
+    sockfd = scp->sockfd;
+    bytes = scp->datalen;
+    in_buf = PR_NEW(buffer);
+    if (in_buf == NULL) {
+        fprintf(stderr,"prsctp_test: SCTP_Serve_Client: failed to alloc buffer struct\n");
+        failed_already=1;
+        goto exit;
+    }
+
+    /*
+     * Subscribe to sctp_data_io_event.
+     */
+    memset(&sod, 0, sizeof(sod));
+    sod.option = PR_SockOpt_Events;
+    sod.value.events.sctp_data_io_event = 1;
+    if (PR_SetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+        fprintf(stderr, "prsctp_test: SCTP_Serve_Client: Set PR_SockOpt_Events failed.\n");
+        failed_already=1;
+        goto exit;
+    }
+
+    for (j = 0; j < num_sctp_mesgs_per_connection; j++) {
+        /*
+         * Read data from client and send it back to the client unmodified
+         */
+        msg_flags = 0;
+
+        rv = readn(sockfd, in_buf->data, bytes, &stream, &msg_flags);
+        if (rv < bytes) {
+            failed_already=1;
+            goto exit;
+        }
+        /*
+         * As currently setup, this test should never return with MSG_NOTIFICATION
+         * or without MSG_EOR
+         */
+        if (!(msg_flags & MSG_EOR) || msg_flags & MSG_NOTIFICATION)
+            fprintf(stderr, "readn returned %s MSG_EOR and %s MSG_NOTIFICATION\n",
+                    (msg_flags & MSG_EOR ? "with" : "without"),
+                    (msg_flags & MSG_NOTIFICATION ? "with" : "without"));
+        /*
+         * shutdown reads, after the last read
+         */
+        if (j == num_sctp_mesgs_per_connection - 1)
+            if (PR_Shutdown(sockfd, PR_SHUTDOWN_RCV) < 0) {
+                fprintf(stderr,"prsocket_test: SCTP_Serve_Client: ERROR - PR_SHUTDOWN_RCV\n");
+            }
+        printf("Serve_Client [0x%p]: inbuf[0] = 0x%d\n",PR_GetCurrentThread(),
+            (*((int *) in_buf->data)));
+        if (PR_SctpSendmsg(sockfd, in_buf->data, bytes, NULL, 0, 0, 0,
+                           stream, 0, 0, PR_INTERVAL_NO_TIMEOUT) < 0) {
+            fprintf(stderr,"prsocket_test: SCTP_Serve_Client: ERROR - PR_SctpSendmsg\n");
+            failed_already=1;
+            goto exit;
+        }
+    }
+    /*
+     * shutdown reads and writes
+     */
+    errno = 0;
+    if (PR_Shutdown(sockfd, PR_SHUTDOWN_BOTH) < 0) {
+        fprintf(stderr,"prsocket_test: SCTP_Serve_Client: ERROR - PR_SHUTDOWN_BOTH\n");
+        failed_already=1;
+    }
+
+exit:
+    PR_Close(sockfd);
+    if (in_buf) {
+        PR_DELETE(in_buf);
+    }
+}
+
+PRThread* create_new_thread(PRThreadType      type,
+                            void              (*start)(void *arg),
+                            void             *arg,
+                            PRThreadPriority  priority,
+                            PRThreadScope     scope,
+                            PRThreadState     state,
+                            PRUint32          stackSize,
+                            PRInt32           index)
+{
+PRInt32 native_thread = 0;
+
+	PR_ASSERT(state == PR_UNJOINABLE_THREAD);
+#if (defined(_PR_PTHREADS) && !defined(_PR_DCETHREADS)) || defined(WIN32)
+	switch(index %  4) {
+		case 0:
+			scope = (PR_LOCAL_THREAD);
+			break;
+		case 1:
+			scope = (PR_GLOBAL_THREAD);
+			break;
+		case 2:
+			scope = (PR_GLOBAL_BOUND_THREAD);
+			break;
+		case 3:
+			native_thread = 1;
+			break;
+		default:
+			PR_ASSERT(!"Invalid scope");
+			break;
+	}
+	if (native_thread) {
+#if defined(_PR_PTHREADS) && !defined(_PR_DCETHREADS)
+		pthread_t *tid = malloc(sizeof(pthread_t));;
+		if (!pthread_create(tid, NULL, (void * (*)(void *)) start, arg))
+			return((PRThread *) tid);
+		else
+			return (NULL);
+#else
+		HANDLE thandle;
+		unsigned tid;
+		
+		thandle = (HANDLE) _beginthreadex(
+						NULL,
+						stackSize,
+						(unsigned (__stdcall *)(void *))start,
+						arg,
+						0,
+						&tid);		
+		return((PRThread *) thandle);
+#endif
+	} else {
+		return(PR_CreateThread(type,start,arg,priority,scope,state,stackSize));
+	}
+#else
+	return(PR_CreateThread(type,start,arg,priority,scope,state,stackSize));
+#endif
+}
+
+/*
+ * SCTP Server
+ *    Server Thread
+ *    Bind an address to a socket and listen for incoming connections
+ *    Start a Serve_Client thread for each incoming connection.
+ */
+static void PR_CALLBACK
+SCTP_Server(void *arg)
+{
+    PRThread *t;
+    Server_Param *sp = (Server_Param *) arg;
+    Serve_Client_Param *scp;
+    PRFileDesc *sockfd, *newsockfd;
+    PRNetAddr netaddr;
+    PRInt32 i;
+    PRSocketOptionData sod;
+
+   /*
+    * Create an SCTP socket
+    */
+    if ((sockfd = PR_OpenSCTPOneToOneSocket(server_domain)) == NULL) {
+        fprintf(stderr,"prsocket_test: PR_OpenSCTPOneToOneSocket failed\n");
+        goto exit;
+    }
+    memset(&netaddr, 0 , sizeof(netaddr));
+
+    if (PR_SetNetAddr(PR_IpAddrAny, server_domain, SCTP_SERVER_PORT,
+                                                            &netaddr) == PR_FAILURE) {
+        fprintf(stderr,"prsocket_test: PR_SetNetAddr failed\n");
+        goto exit;
+    }
+   /*
+    * try a few times to bind server's address, if addresses are in use
+    */
+    i = 0;
+
+    while (PR_Bind(sockfd, &netaddr) < 0) {
+        if (PR_GetError() == PR_ADDRESS_IN_USE_ERROR) {
+            netaddr.inet.port += 2;
+            if (i++ < SERVER_MAX_BIND_COUNT)
+            continue;
+        }
+        fprintf(stderr,"prsocket_test: ERROR - PR_Bind failed\n");
+        perror("PR_Bind");
+        failed_already=1;
+        goto exit;
+    }
+
+       /*
+        * Set SCTP_NODELAY
+        */
+        memset(&sod, 0, sizeof(sod));
+        sod.option = PR_SockOpt_SctpNoDelay;
+        sod.value.sctp_nodelay = 1;
+        if (PR_SetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "prsctp_test: SCTP_Server: Set PR_SockOpt_SctpNoDelay failed.\n");
+            failed_already=1;
+            return;
+        }
+
+    if (PR_Listen(sockfd, 32) < 0) {
+        fprintf(stderr,"prsctp_test: SCTP_Server: ERROR - PR_Listen failed\n");
+        failed_already=1;
+        goto exit;
+    }
+
+    if (PR_GetSockName(sockfd, &netaddr) < 0) {
+        fprintf(stderr,"prsctp_test: SCTP_Server: ERROR - PR_GetSockName failed\n");
+        failed_already=1;
+        goto exit;
+    }
+
+    printf("SCTP_Server: PR_BIND netaddr.inet.ip = 0x%d, netaddr.inet.port = %d\n",
+        netaddr.inet.ip, netaddr.inet.port);
+    if (PR_SetNetAddr(PR_IpAddrLoopback, client_domain,
+                      PR_ntohs(PR_NetAddrInetPort(&netaddr)),
+                      &sctp_server_addr) == PR_FAILURE) {
+        fprintf(stderr,"prsctp_test: SCTP_Server: ERROR - PR_SetNetAddr failed\n");
+        goto exit;
+    }
+    if ((client_domain == PR_AF_INET6) && (server_domain == PR_AF_INET))
+        PR_ConvertIPv4AddrToIPv6(PR_htonl(INADDR_LOOPBACK),
+                                 &sctp_server_addr.ipv6.ip);
+
+   /*
+    * Wake up parent thread because server address is bound and made
+    * available in the global variable 'sctp_server_addr'
+    */
+    PR_Lock(sp->serv_lock);
+    PR_NotifyCondVar(sp->serv_cond);
+    PR_Unlock(sp->serv_lock);
+
+    for (i = 0; i < (num_sctp_clients * num_sctp_connections_per_client); i++) {
+        /* test both null and non-null 'addr' argument to PR_Accept */
+        PRNetAddr *addrp = (i%2 ? &netaddr: NULL);
+
+    printf("SCTP_Server: Accepting connection\n");
+        if ((newsockfd = PR_Accept(sockfd, addrp,
+            PR_INTERVAL_NO_TIMEOUT)) == NULL) {
+            fprintf(stderr,"prsocket_test: SCTP_Server: ERROR - PR_Accept failed\n");
+            goto exit;
+        }
+    printf("SCTP_Server: Accepted connection\n");
+        scp = PR_NEW(Serve_Client_Param);
+        if (scp == NULL) {
+            fprintf(stderr,"prsocket_test: SCTP_Server: ERROR - PR_NEW failed\n");
+            goto exit;
+        }
+
+        /*
+         * Start a Serve_Client thread for each incoming connection
+         */
+        scp->sockfd = newsockfd;
+        scp->datalen = sp->datalen;
+
+        t = create_new_thread(PR_USER_THREAD,
+            SCTP_Serve_Client, (void *)scp, 
+            PR_PRIORITY_NORMAL,
+            PR_LOCAL_THREAD,
+            PR_UNJOINABLE_THREAD,
+            0, i);
+        if (t == NULL) {
+            fprintf(stderr,"prsocket_test: SCPT_Server: ERROR - PR_CreateThread failed\n");
+            failed_already=1;
+            goto exit;
+        }
+        printf("SCTP_Server: Created Serve_Client = 0x%p\n", t);
+    }
+
+exit:
+    if (sockfd) {
+        PR_Close(sockfd);
+    }
+
+    /*
+     * Decrement exit_counter and notify parent thread
+     */
+
+    PR_EnterMonitor(sp->exit_mon);
+    --(*sp->exit_counter);
+    PR_Notify(sp->exit_mon);
+    PR_ExitMonitor(sp->exit_mon);
+    printf("SCTP_Server [0x%p] exiting\n", PR_GetCurrentThread());
+}
+
+/*
+ * SCTP_Client
+ *    Client Thread
+ *    Connect to the server at the address specified in the argument.
+ *    Fill in a buffer, write data to server, read it back and check
+ *    for data corruption.
+ *    Close the socket for server connection
+ */
+static void PR_CALLBACK
+SCTP_Client(void *arg)
+{
+    Client_Param *cp = (Client_Param *) arg;
+    PRFileDesc *sockfd;
+    buffer *in_buf, *out_buf;
+    union PRNetAddr netaddr;
+    PRInt32 bytes, i, j;
+    PRInt32 stream;
+    PRInt32 msg_flags=0;
+    int rv;
+    PRSocketOptionData sod;
+
+    bytes = cp->datalen;
+    out_buf = PR_NEW(buffer);
+    if (out_buf == NULL) {
+        fprintf(stderr,"prsocket_test: failed to alloc buffer struct\n");
+        failed_already=1;
+        return;
+    }
+    in_buf = PR_NEW(buffer);
+    if (in_buf == NULL) {
+        fprintf(stderr,"prsocket_test: failed to alloc buffer struct\n");
+        failed_already=1;
+        return;
+    }
+    netaddr = cp->server_addr;
+
+   /*
+    * Open all connections
+    */
+    for (i = 0; i < num_sctp_connections_per_client; i++) {
+        if ((sockfd = PR_OpenSCTPOneToOneSocket(client_domain)) == NULL) {
+            fprintf(stderr,"prsocket_test: PR_OpenSCTPOneToOneSocket failed\n");
+            failed_already=1;
+            return;
+        }
+
+       /*
+        * Set SCTP_NODELAY
+        */
+        memset(&sod, 0, sizeof(sod));
+        sod.option = PR_SockOpt_SctpNoDelay;
+        sod.value.sctp_nodelay = 1;
+        if (PR_SetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "SCTP_Client: Set PR_SockOpt_SctpNoDelay failed.\n");
+            failed_already=1;
+            return;
+        }
+
+       /*
+        * subscribe to the sctp_data_io_event
+        */
+        memset(&sod, 0, sizeof(sod));
+        sod.option = PR_SockOpt_Events;
+        sod.value.events.sctp_data_io_event = 1;
+        if (PR_SetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "SCTP_Client: Set PR_SockOpt_Events failed.\n");
+            failed_already=1;
+            return;
+        }
+
+       /*
+        * Request NUM_SCTP_STREAMS outgoing streams
+        */
+        memset(&sod, 0, sizeof(sod));
+        sod.option = PR_SockOpt_InitMsg;
+        if (PR_GetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "SCTP_Client: Get PR_SockOpt_InitMsg failed.\n");
+            failed_already=1;
+            return;
+        }
+        sod.value.initmsg.sinit_num_ostreams = NUM_SCTP_STREAMS;
+        if (PR_SetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "SCTP_Client: Set PR_SockOpt_InitMsg failed.\n");
+            failed_already=1;
+            return; 	
+        }
+
+       /*
+        * Connect to server
+        */
+        if (PR_Connect(sockfd, &netaddr,PR_INTERVAL_NO_TIMEOUT) < 0){
+        	fprintf(stderr, "PR_Connect failed: (%d, %d)\n",
+            		PR_GetError(), PR_GetOSError());
+            failed_already=1;
+            return;
+        }
+
+       /*
+        * Check number of outgoing streams
+        */
+        memset(&sod, 0, sizeof(sod));
+        sod.option = PR_SockOpt_Status;
+        if (PR_GetSocketOption(sockfd, &sod) != PR_SUCCESS) {
+            fprintf(stderr, "prsctp_test: SCTP_Serve_Client: Get PR_SockOpt_Status failed.\n");
+            failed_already=1;
+            return;
+        }
+        if (NUM_SCTP_STREAMS != sod.value.status.sstat_outstrms)
+            fprintf(stderr, "prsctp_test: SCTP_Serve_Client: Number of outgoing streams different from request.\n");
+
+       /*
+        * Send and receive all messages for this connection
+        */
+        for (j = 0; j < num_sctp_mesgs_per_connection; j++) {
+           /*
+            * fill in random data
+            */
+            memset(out_buf->data, *((PRInt32*) (&netaddr)) + i + j, bytes);
+           /*
+            * write to server
+            */
+            stream = j % NUM_SCTP_STREAMS;
+            if (PR_SctpSendmsg(sockfd, out_buf->data, bytes, NULL, 0, 0, 0,
+                               stream, 0, 0, PR_INTERVAL_NO_TIMEOUT) < 0) {
+                fprintf(stderr,"prsctp_test: SCTP_Client: ERROR - PR_SctpSendmsg\n");
+                failed_already=1;
+                return;
+            }
+            printf("SCTP Client [0x%p]: out_buf = 0x%p out_buf[0] = 0x%x\n",
+                PR_GetCurrentThread(), out_buf, (*((int *) out_buf->data)));
+
+            msg_flags = 0;
+            rv = readn(sockfd, in_buf->data, bytes, &stream, &msg_flags);
+            if (rv < bytes) {
+                failed_already=1;
+                return;
+            }
+           /*
+            * As currently setup, this test should never return with MSG_NOTIFICATION
+            * or without MSG_EOR
+            */
+            if (!(msg_flags & MSG_EOR) || msg_flags & MSG_NOTIFICATION)
+                fprintf(stderr, "readn returned %s MSG_EOR and %s MSG_NOTIFICATION\n",
+                        (msg_flags & MSG_EOR ? "with" : "without"),
+                        (msg_flags & MSG_NOTIFICATION ? "with" : "without"));
+           /*
+            * verify the stream number
+            */
+            if (stream != j) {
+                fprintf(stderr, "prsctp_test: SCTP_Client: ERROR - response not received on expected stream number.\n");
+                failed_already=1;
+                return;
+            }
+           /*
+            * verify the data read
+            */
+            if (memcmp(in_buf->data, out_buf->data, bytes) != 0) {
+                fprintf(stderr,"prsctpt_test: SCTP_Client: ERROR - data corruption\n");
+                failed_already=1;
+                return;
+            }
+        }
+        /*
+         * shutdown reads and writes
+         */
+        if (PR_Shutdown(sockfd, PR_SHUTDOWN_BOTH) < 0) {
+            fprintf(stderr,"prsctp_test: SCTP_Client: ERROR - PR_SHUTDOWN_BOTH\n");
+            failed_already=1;
+        }
+        PR_Close(sockfd);
+    }
+
+    PR_DELETE(out_buf);
+    PR_DELETE(in_buf);
+
+    /*
+     * Decrement exit_counter and notify parent thread
+     */
+    PR_EnterMonitor(cp->exit_mon);
+    --(*cp->exit_counter);
+    PR_Notify(cp->exit_mon);
+    PR_ExitMonitor(cp->exit_mon);
+    printf("SCTP_Client [0x%p] exiting\n", PR_GetCurrentThread());
+}
+
+/*
+ * SCTP_Socket_Client_Server_Test    - concurrent server test
+ *    
+ *    One server and several clients are started
+ *    Each client connects to the server and sends a chunk of data
+ *    For each connection, server starts another thread to read the data
+ *    from the client and send it back to the client, unmodified.
+ *    Each client checks that data received from server is same as the
+ *    data it sent to the server.
+ *
+ */
+
+static PRInt32
+SCTP_Socket_Client_Server_Test(void)
+{
+    int i;
+    PRThread *t;
+    Server_Param *sparamp;
+    Client_Param *cparamp;
+    PRMonitor *mon2;
+    PRInt32    datalen;
+    PRLock *server_lock;
+    PRCondVar *server_up;
+
+    datalen = sctp_mesg_size;
+    thread_count = 0;
+    /*
+     * start the server thread
+     */
+    sparamp = PR_NEW(Server_Param);
+    if (sparamp == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_NEW failed\n");
+        failed_already=1;
+        return -1;
+    }
+    mon2 = PR_NewMonitor();
+    if (mon2 == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_NewMonitor failed\n");
+        failed_already=1;
+        return -1;
+    }
+    PR_EnterMonitor(mon2);
+
+    /* server_lock controls access to server_up condition variable */
+    server_lock = PR_NewLock();
+    if (server_lock == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_NewLock failed\n");
+        failed_already=1;
+        return -1;
+    }
+    /* server_up is notified when server address is available */
+    server_up = PR_NewCondVar(server_lock);
+    if (server_up == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_NewCondVar failed\n");
+        failed_already=1;
+        return -1;
+    }
+
+    PR_Lock(server_lock);
+
+    /* sparamp->addr_sem = server_sem; */
+    sparamp->exit_mon = mon2;
+    sparamp->exit_counter = &thread_count;
+    sparamp->datalen = datalen;
+    sparamp->serv_lock = server_lock;
+    sparamp->serv_cond = server_up;
+    t = PR_CreateThread(PR_USER_THREAD,
+        SCTP_Server, (void *)sparamp, 
+        PR_PRIORITY_NORMAL,
+        PR_LOCAL_THREAD,
+        PR_UNJOINABLE_THREAD,
+        0);
+    if (t == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_CreateThread failed\n");
+        failed_already=1;
+        return -1;
+    }
+    printf("Created SCTP_Server = 0x%p\n", t);
+    thread_count++;
+
+    /* wait for server to notify that address is available */
+    PR_WaitCondVar(server_up, PR_INTERVAL_NO_TIMEOUT);
+
+    /* release lock and cleanup */
+    PR_Unlock(server_lock);
+    PR_DestroyCondVar(server_up);
+    PR_DestroyLock(server_lock);
+
+    /*
+     * Now start a bunch of client threads
+     */
+
+    cparamp = PR_NEW(Client_Param);
+    if (cparamp == NULL) {
+        fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_NEW failed\n");
+        failed_already=1;
+        return -1;
+    }
+    cparamp->server_addr = sctp_server_addr;
+    cparamp->exit_mon = mon2;
+    cparamp->exit_counter = &thread_count;
+    cparamp->datalen = datalen;
+    for (i = 0; i < num_sctp_clients; i++) {
+        t = create_new_thread(PR_USER_THREAD,
+            SCTP_Client, (void *) cparamp,
+            PR_PRIORITY_NORMAL,
+            PR_LOCAL_THREAD,
+            PR_UNJOINABLE_THREAD,
+            0, i);
+        if (t == NULL) {
+            fprintf(stderr,"prsocket_test: SCTP_Socket_Client_Server_Test: ERROR - PR_CreateThread failed\n");
+            failed_already=1;
+            return -1;
+        }
+        printf("Created SCTP_Client = 0x%p\n", t);
+        thread_count++;
+    }
+    /* Wait for server and client threads to exit */
+    while (thread_count) {
+        PR_Wait(mon2, PR_INTERVAL_NO_TIMEOUT);
+        printf("SCTP Server - thread_count  = %d\n", thread_count);
+    }
+    PR_ExitMonitor(mon2);
+    printf("%30s","SCTP_Socket_Client_Server_Test:");
+    printf("%2ld Server %2d Clients %2d connections_per_client\n",1l,
+        num_sctp_clients, num_sctp_connections_per_client);
+    printf("%30s %2d messages_per_connection %4d bytes_per_message\n",":",
+        num_sctp_mesgs_per_connection, sctp_mesg_size);
+
+    return 0;
+}
+
+/*
+ * Test Socket NSPR APIs
+ */
+ 	
+int main(int argc, char **argv)
+{
+    /*
+     * -d           debug mode
+     */
+
+    PLOptStatus os;
+    PLOptState *opt = PL_CreateOptState(argc, argv, "d");
+    while (PL_OPT_EOL != (os = PL_GetNextOpt(opt)))
+    {
+        if (PL_OPT_BAD == os) continue;
+        switch (opt->option)
+        {
+        case 'd':  /* debug mode */
+            _debug_on = 1;
+            break;
+        default:
+            break;
+        }
+    }
+    PL_DestroyOptState(opt);
+
+    PR_Init(PR_USER_THREAD, PR_PRIORITY_NORMAL, 0);
+    PR_STDIO_INIT();
+ 	
+    PR_SetConcurrency(4);
+
+    /*
+     * run client-server test with SCTP, Ipv4-Ipv4
+     */
+	printf("SCTP Client/Server Test - IPv4/Ipv4\n");
+    if (SCTP_Socket_Client_Server_Test() < 0) {
+        printf("SCTP_Socket_Client_Server_Test failed\n");
+        goto done;
+    } else
+        printf("SCTP_Socket_Client_Server_Test Passed\n");
+
+done:
+    PR_Cleanup();
+    if (failed_already) return 1;
+    else return 0;
+}
diff --git a/xpcom/base/ErrorList.h b/xpcom/base/ErrorList.h
--- a/xpcom/base/ErrorList.h
+++ b/xpcom/base/ErrorList.h
@@ -262,16 +262,31 @@
   /* The specified socket type does not exist. */
   ERROR(NS_ERROR_UNKNOWN_SOCKET_TYPE,   FAILURE(51)),
   /* The specified socket type could not be created. */
   ERROR(NS_ERROR_SOCKET_CREATE_FAILED,  FAILURE(52)),
   /* The operating system doesn't support the given type of address. */
   ERROR(NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED, FAILURE(53)),
   /* The address to which we tried to bind the socket was busy. */
   ERROR(NS_ERROR_SOCKET_ADDRESS_IN_USE, FAILURE(54)),
+#if defined(ENABLE_SCTP)
+/**
+ * The specified socket is of the wrong type.
+ * Returned by SCTP-only routines for TCP sockets
+ */
+  ERROR(NS_ERROR_INVALID_SOCKET_TYPE, FAILURE(53)),
+/**
+ * The specified socket does not exist.
+ */
+  ERROR(NS_ERROR_SOCKET_DOES_NOT_EXIST, FAILURE(54)),
+/**
+ * The attempt to set/get a socket option failed.
+ */
+  ERROR(NS_ERROR_SOCKET_OPTION_FAILED, FAILURE(55)),
+#endif
 
   /* Cache specific error codes: */
   ERROR(NS_ERROR_CACHE_KEY_NOT_FOUND,        FAILURE(61)),
   ERROR(NS_ERROR_CACHE_DATA_IS_STREAM,       FAILURE(62)),
   ERROR(NS_ERROR_CACHE_DATA_IS_NOT_STREAM,   FAILURE(63)),
   ERROR(NS_ERROR_CACHE_WAIT_FOR_VALIDATION,  FAILURE(64)),
   ERROR(NS_ERROR_CACHE_ENTRY_DOOMED,         FAILURE(65)),
   ERROR(NS_ERROR_CACHE_READ_ACCESS_DENIED,   FAILURE(66)),
@@ -284,16 +299,29 @@
   /* Effective TLD Service specific error codes: */
 
   /* The requested number of domain levels exceeds those present in the host
    * string. */
   ERROR(NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS,  FAILURE(80)),
   /* The host string is an IP address. */
   ERROR(NS_ERROR_HOST_IS_IP_ADDRESS,          FAILURE(81)),
 
+#if defined(ENABLE_SCTP)
+ /**
+  * The next SCTP message is available to be read, but it is on a different SCTP
+  * stream than the SCTP message that has just been read.  This error implies
+  * NS_SCTP_WRONG_TRANSACTION, as well.
+  */
+  ERROR(NS_SCTP_INPUT_STREAM_ID_CHANGED,       FAILURE(90)),
+ /**
+  * The next SCTP message is available to be read, but it is does not belong
+  * to the current transaction.
+  */
+  ERROR(NS_SCTP_WRONG_TRANSACTION,             FAILURE(91)),
+#endif
 
   /* StreamLoader specific result codes: */
 
   /* Result code returned by nsIStreamLoaderObserver to indicate that the
    * observer is taking over responsibility for the data buffer, and the loader
    * should NOT free it. */
   ERROR(NS_SUCCESS_ADOPTED_DATA,  SUCCESS(90)),
 

